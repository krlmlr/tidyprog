[
["index.html", "Programming in the tidyverse Preface Links Package versions used License", " Programming in the tidyverse Kirill Müller, Tobias Schieferdecker 29 May 2019, 21:55 CEST Preface Material for the zhRcourse workshop “Programming in the tidyverse” on May 10, 2019. See the controls at the top of the website for searching, font size, editing, and a link to the PDF version of the material. Links This website: https://bit.ly/tidyprog Longer URL: https://krlmlr.github.io/tidyprog/ Scripts and installation instructions: https://github.com/krlmlr/tidyprog-proj/tree/2019-05-zhr Prepared scripts: https://github.com/krlmlr/tidyprog-proj/tree/2019-05-zhr/script Live code: https://github.com/krlmlr/tidyprog-proj/tree/2019-05-zhr/live The code will be updated live with a delay of a few seconds during the workshop, it is not necessary to repeat the instructor’s typing rstudio.cloud server: https://rstudio.cloud/project/329883 Sign up, or log in with Google or GitHub Click the “Save a private copy” link next to the TEMPORARY label in red in the header All necessary packages are preinstalled The source project for this material: https://github.com/krlmlr/tidyprog Package versions used Click to expand withr::with_options(list(width = 80), print(sessioninfo::session_info())) ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.0 (2017-01-27) ## os Ubuntu 16.04.6 LTS ## system x86_64, linux-gnu ## ui X11 ## language en_US.UTF-8 ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2019-05-29 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.6.0) ## backports 1.1.4 2019-04-10 [1] CRAN (R 3.6.0) ## bookdown 0.9 2018-12-21 [1] CRAN (R 3.6.0) ## broom 0.5.2 2019-04-07 [1] CRAN (R 3.6.0) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 3.6.0) ## cli 1.1.0 2019-03-19 [1] CRAN (R 3.6.0) ## codetools 0.2-16 2018-12-24 [3] CRAN (R 3.6.0) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 3.6.0) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.6.0) ## curl 3.3 2019-01-10 [1] CRAN (R 3.6.0) ## digest 0.6.19 2019-05-20 [1] CRAN (R 3.6.0) ## dplyr * 0.8.1 2019-05-14 [1] CRAN (R 3.6.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 3.6.0) ## fansi 0.4.0 2018-10-05 [1] CRAN (R 3.6.0) ## forcats * 0.4.0 2019-02-17 [1] CRAN (R 3.6.0) ## fs 1.3.1 2019-05-06 [1] CRAN (R 3.6.0) ## generics 0.0.2 2018-11-29 [1] CRAN (R 3.6.0) ## ggplot2 * 3.1.1 2019-04-07 [1] CRAN (R 3.6.0) ## glue 1.3.1 2019-03-12 [1] CRAN (R 3.6.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 3.6.0) ## haven 2.1.0 2019-02-19 [1] CRAN (R 3.6.0) ## here * 0.1 2017-05-28 [1] CRAN (R 3.6.0) ## hms 0.4.2 2018-03-10 [1] CRAN (R 3.6.0) ## htmltools 0.3.6 2017-04-28 [1] CRAN (R 3.6.0) ## httr 1.4.0 2018-12-11 [1] CRAN (R 3.6.0) ## jsonlite 1.6 2018-12-07 [1] CRAN (R 3.6.0) ## knitr 1.23 2019-05-18 [1] CRAN (R 3.6.0) ## labeling 0.3 2014-08-23 [1] CRAN (R 3.6.0) ## lattice 0.20-38 2018-11-04 [3] CRAN (R 3.6.0) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 3.6.0) ## lubridate 1.7.4 2018-04-11 [1] CRAN (R 3.6.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 3.6.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 3.6.0) ## modelr 0.1.4 2019-02-18 [1] CRAN (R 3.6.0) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.6.0) ## nlme 3.1-139 2019-04-09 [3] CRAN (R 3.6.0) ## nycflights13 1.0.0 2018-06-26 [1] CRAN (R 3.6.0) ## pillar 1.4.1 2019-05-28 [1] CRAN (R 3.6.0) ## pkgconfig 2.0.2 2018-08-16 [1] CRAN (R 3.6.0) ## plyr 1.8.4 2016-06-08 [1] CRAN (R 3.6.0) ## purrr * 0.3.2 2019-03-15 [1] CRAN (R 3.6.0) ## R6 2.4.0 2019-02-14 [1] CRAN (R 3.6.0) ## Rcpp 1.0.1 2019-03-17 [1] CRAN (R 3.6.0) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 3.6.0) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 3.6.0) ## rlang * 0.3.4 2019-04-07 [1] CRAN (R 3.6.0) ## rmarkdown 1.13 2019-05-22 [1] CRAN (R 3.6.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.6.0) ## rstudioapi 0.10 2019-03-19 [1] CRAN (R 3.6.0) ## rvest 0.3.4 2019-05-15 [1] CRAN (R 3.6.0) ## scales 1.0.0 2018-08-09 [1] CRAN (R 3.6.0) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.6.0) ## stringi 1.4.3 2019-03-12 [1] CRAN (R 3.6.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 3.6.0) ## tibble * 2.1.1 2019-03-16 [1] CRAN (R 3.6.0) ## tic 0.2.13.9016 2019-05-29 [1] Github (ropenscilabs/tic@31cd3db) ## tidyr * 0.8.3 2019-03-01 [1] CRAN (R 3.6.0) ## tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.6.0) ## tidyverse * 1.2.1 2017-11-14 [1] CRAN (R 3.6.0) ## tinytex 0.13 2019-05-14 [1] CRAN (R 3.6.0) ## utf8 1.1.4 2018-05-24 [1] CRAN (R 3.6.0) ## vctrs 0.1.0 2018-11-29 [1] CRAN (R 3.6.0) ## withr 2.1.2 2018-03-15 [1] CRAN (R 3.6.0) ## xfun 0.7 2019-05-14 [1] CRAN (R 3.6.0) ## xml2 1.2.0 2018-01-24 [1] CRAN (R 3.6.0) ## yaml 2.2.0 2018-07-25 [1] CRAN (R 3.6.0) ## zeallot 0.1.0 2018-01-28 [1] CRAN (R 3.6.0) ## ## [1] /home/travis/R/Library ## [2] /usr/local/lib/R/site-library ## [3] /home/travis/R-bin/lib/R/library License Licensed under CC-BY-NC 4.0. "],
["introduction.html", "1 Introduction 1.1 Overview 1.2 Review of visualization and data transformation", " 1 Introduction The tidyverse has quickly developed over the last years. Its first implementation as a collection of partly older packages was in the second half of 2016. All its packages “share an underlying design philosophy, grammar, and data structures.”1 It is for sure difficult to tell, if “learning the tidyverse” is a hard task, since the result of this assessment might differ from person to person. We do believe though, that there are concepts in its approach, which – when grasped – have the potential to increase one’s productivity, since code creation will seem more natural. While this might be true for all languages (once you speak it well enough, things go smoothly), in our opinion the tidyverse worth exploring in depth, since it is consistent: an especially well designed framework that aims at making data analysis and programming intuitive, evolving: constantly deepened understanding for challenges arising in modern data analysis leads to improving ergonomic user interfaces. This section gives a brief overview, introduces the data used for the course, and offers a refresher for tidy data manipulation and visualization. 1.1 Overview This course covers several topics, which everyone working more intently with the tidyverse almost inevitably needs to deal with at some point or another. The topics are organized in chapters that contain mostly R code with output and text. In each section, exercises are provided. Each subsection corresponds to an R script in the script directory in the sister repository on GitHub. For example, the code from the next section 1.2 can be found in 12-intro.R. Clone or download the repository and open the R-workshop.Rproj file to run the script. (It is important to open the .Rproj file and not only the .R scripts.) Function basics structuring the code to avoid too much copy-pasting Using functions to structure code. This part is independent of the subsequent section. We begin with how to define and execute a function Discussion of a function’s arguments (from both the developers’ and the users’ perspective) A few words on function design Simple iteration processing multiple files that contain different parts of the same dataset This part introduces iteration and is independent of the previous section. How to get from a list or a vector to a tibble and vice-versa Indexing for vectors and lists Applying a function to each element of a list or a vector Pairwise iteration and nesting More advanced iteration. Simultaneously feed two or more separate lists of inputs into a function working with those two arguments Iterate rowwise through columns in a tibble Nested tibbles, a very powerful concept Scoping and flow control More advanced functional concepts. Data lifecycle Purity Control flow Metaprogramming Non-rectangular data working with raw data from online services (JSON) Processing hierarchical lists as commonly returned from web APIs. Data lifecycle Purity Control flow Metaprogramming Tidy evaluation writing functions that work with datasets of different shape TBD 1.2 Review of visualization and data transformation This section is a refresher for visualization and data transformation in the tidyverse. Readers familiar with the first half or R for data science will recognize the concepts repeated here. The data used throughout this course is presented, plotted and briefly analyzed. The code in each chapter is self-contained. The code in each section is also self-contained, but the necessary setup code is hidden and can be expanded with a click. We will always load the following packages: library(tidyverse) library(here) Functions from other packages may be used with the :: notation. 1.2.1 Data We will be working with hourly measurements of weather data (link to data documentation) in four cities (Berlin, Toronto, Tel Aviv and Zurich) between 2019-04-28, 3pm and 2019-04-30, 3pm. Thus we have 49 observations in each city. Variables are: time summary (how to describe the weather in one word) icon (mix of description of weather plus time of day) precipIntensity (intensity of precipitation [mm/h]) precipProbability temperature apparentTemperature dewPoint humidity pressure windSpeed windGust windBearing (direction in degrees) cloudCover uvIndex visibility ozone precipType Reading in the data, which is stored in MS Excel-Files: berlin &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;berlin.xlsx&quot;)) toronto &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;toronto.xlsx&quot;)) tel_aviv &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;tel_aviv.xlsx&quot;)) zurich &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;zurich.xlsx&quot;)) Create one larger tibble from the four smaller ones: weather_data &lt;- bind_rows( berlin = berlin, toronto = toronto, tel_aviv = tel_aviv, zurich = zurich, .id = &quot;city_code&quot; ) 1.2.2 Exploration weather_data ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; Example plot of humidity vs. pressure (geom_path() ensures that points are connected according to their order in the tibble): weather_data %&gt;% ggplot(aes(x = pressure, y = humidity, color = city_code)) + geom_path() Barplots of number of occurences of each kind of weather per city: weather_data %&gt;% ggplot(aes(x = city_code)) + geom_bar(aes(fill = summary)) weather_data %&gt;% ggplot(aes(x = city_code)) + geom_bar(aes(fill = summary), position = position_dodge2(&quot;dodge&quot;, preserve = &quot;single&quot;)) Lineplot with different line types and an additional visualisation of the line range (here, difference between apparent and actual temperature): weather_data %&gt;% select(city_code, time, temperature, apparentTemperature) %&gt;% gather(kind, temperature, -city_code, -time) ## # A tibble: 392 x 4 ## city_code time kind temperature ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 temperature 13.4 ## 2 berlin 2019-04-28 16:00:00 temperature 13.6 ## 3 berlin 2019-04-28 17:00:00 temperature 14.1 ## # … with 389 more rows temperature_data &lt;- weather_data %&gt;% select(city_code, time, temperature, apparentTemperature) %&gt;% gather(kind, temperature, -city_code, -time) %&gt;% mutate(apparent = (kind == &quot;apparentTemperature&quot;)) %&gt;% select(-kind) temperature_data ## # A tibble: 392 x 4 ## city_code time temperature apparent ## &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 berlin 2019-04-28 15:00:00 13.4 FALSE ## 2 berlin 2019-04-28 16:00:00 13.6 FALSE ## 3 berlin 2019-04-28 17:00:00 14.1 FALSE ## # … with 389 more rows temperature_data %&gt;% ggplot(aes(x = time, color = city_code)) + geom_linerange(data = weather_data, aes(ymin = temperature, ymax = apparentTemperature)) + geom_line(aes(linetype = apparent, y = temperature)) Relation of temperature difference between actual and apparent temperature (cf. line range in last plot) with wind speed, shown as scatter plot. weather_data %&gt;% mutate(apparentTemperatureReduction = temperature - apparentTemperature) %&gt;% filter(city_code != &quot;tel_aviv&quot;) %&gt;% ggplot(aes(x = windSpeed, y = apparentTemperatureReduction)) + geom_point(aes(color = city_code)) 1.2.3 Further dplyr transformations If you want to compare measurements of the same observable at two different points in time, maybe the most straightforward way to do so is to create a new column with an appropriate lag: weather_data %&gt;% group_by(city_code) %&gt;% mutate_at(vars(temperature, pressure, humidity), list(lag = lag)) %&gt;% ungroup() ## # A tibble: 196 x 22 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 193 more rows, and 17 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt;, temperature_lag &lt;dbl&gt;, ## # pressure_lag &lt;dbl&gt;, humidity_lag &lt;dbl&gt; Count observations per category or combinations of categories: weather_data %&gt;% count(city_code) ## # A tibble: 4 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 toronto 49 ## 4 zurich 49 weather_data %&gt;% count(city_code, summary) ## # A tibble: 15 x 3 ## city_code summary n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 berlin Clear 17 ## 2 berlin Mostly Cloudy 11 ## 3 berlin Overcast 18 ## # … with 12 more rows Use summarize() to create a tibble with mean and maximum temperature for each city: weather_data %&gt;% group_by(city_code) %&gt;% summarize(temperature_mean = mean(temperature), temperature_max = max(temperature)) %&gt;% ungroup() ## # A tibble: 4 x 3 ## city_code temperature_mean temperature_max ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 berlin 12.5 20.0 ## 2 tel_aviv 22.6 28.8 ## 3 toronto 6.39 9.99 ## 4 zurich 7.15 14.3 Compute and display summary data for all numeric variables: weather_data %&gt;% group_by(city_code) %&gt;% summarize_if(is.numeric, list(mean = mean, sd = sd, min = min, max = max)) %&gt;% ungroup() %&gt;% gather(key, value, -city_code) %&gt;% separate(key, into = c(&quot;indicator&quot;, &quot;fun&quot;)) %&gt;% xtabs(value ~ city_code + indicator + fun, .) %&gt;% ftable() ## fun max mean min sd ## city_code indicator ## berlin apparentTemperature 19.98000000 11.62836735 3.45000000 5.07360997 ## cloudCover 1.00000000 0.59734694 0.00000000 0.42339292 ## dewPoint 10.18000000 5.23632653 1.88000000 2.45837742 ## humidity 0.88000000 0.63448980 0.35000000 0.15571156 ## ozone 378.04000000 343.34571429 319.68000000 21.60874350 ## precipIntensity 0.34800000 0.03084286 0.00000000 0.07902264 ## precipProbability 0.54000000 0.06000000 0.00000000 0.13913423 ## pressure 1020.48000000 1018.71714286 1016.10000000 1.19202733 ## temperature 19.98000000 12.49795918 6.14000000 4.10004115 ## uvIndex 5.00000000 1.24489796 0.00000000 1.61413821 ## visibility 16.09000000 15.77102041 10.01000000 1.13380672 ## windBearing 358.00000000 151.59183673 4.00000000 152.79205891 ## windGust 11.14000000 7.59591837 3.67000000 2.18713275 ## windSpeed 5.89000000 4.49326531 3.51000000 0.81341458 ## tel_aviv apparentTemperature 28.77000000 22.64591837 17.15000000 3.15235885 ## cloudCover 0.81000000 0.19693878 0.00000000 0.24908335 ## dewPoint 14.43000000 12.18244898 9.51000000 1.29219376 ## humidity 0.74000000 0.52612245 0.34000000 0.09347050 ## ozone 339.37000000 318.31836735 307.16000000 10.05895835 ## precipIntensity 0.00000000 0.00000000 0.00000000 0.00000000 ## precipProbability 0.00000000 0.00000000 0.00000000 0.00000000 ## pressure 1015.88000000 1013.66265306 1011.73000000 1.12583076 ## temperature 28.77000000 22.64591837 17.15000000 3.15235885 ## uvIndex 10.00000000 2.40816327 0.00000000 3.56439784 ## visibility 16.09000000 15.87163265 10.01000000 1.07987528 ## windBearing 355.00000000 188.36734694 0.00000000 123.84965581 ## windGust 5.53000000 3.47775510 1.66000000 1.19411101 ## windSpeed 4.90000000 2.49285714 0.57000000 1.04899754 ## toronto apparentTemperature 7.88000000 3.27306122 0.49000000 2.24842464 ## cloudCover 1.00000000 0.59510204 0.00000000 0.43183293 ## dewPoint 3.05000000 -1.26653061 -5.17000000 2.69193359 ## humidity 0.82000000 0.59734694 0.37000000 0.14628419 ## ozone 401.89000000 362.02632653 327.57000000 23.42483179 ## precipIntensity 0.84070000 0.08387551 0.00000000 0.16627247 ## precipProbability 0.51000000 0.06653061 0.00000000 0.11739447 ## pressure 1030.07000000 1025.14918367 1019.55000000 3.22083053 ## temperature 9.99000000 6.38795918 3.03000000 2.02387621 ## uvIndex 6.00000000 1.40816327 0.00000000 1.84750245 ## visibility 16.09000000 15.14673469 5.13000000 2.83815256 ## windBearing 357.00000000 140.32653061 2.00000000 129.30831820 ## windGust 11.51000000 7.51020408 2.66000000 2.33711939 ## windSpeed 7.64000000 4.87510204 1.91000000 1.62389080 ## zurich apparentTemperature 14.30000000 6.88551020 2.01000000 3.14469133 ## cloudCover 1.00000000 0.80877551 0.37000000 0.15734295 ## dewPoint 7.23000000 3.38367347 -0.27000000 1.90397030 ## humidity 0.88000000 0.77551020 0.59000000 0.08304269 ## ozone 377.57000000 359.81510204 340.69000000 11.33226737 ## precipIntensity 0.26670000 0.07106939 0.00000000 0.05976032 ## precipProbability 0.29000000 0.13326531 0.00000000 0.07816616 ## pressure 1023.55000000 1021.37612245 1017.40000000 1.62120174 ## temperature 14.30000000 7.14510204 2.01000000 3.07049475 ## uvIndex 4.00000000 1.10204082 0.00000000 1.44690615 ## visibility 16.09000000 12.90938776 3.89000000 4.47872769 ## windBearing 357.00000000 147.61224490 20.00000000 102.66182679 ## windGust 4.76000000 1.98428571 1.07000000 0.95327506 ## windSpeed 4.76000000 1.31244898 0.13000000 0.91823774 citation from tidyverse homepage↩ "],
["function-basics.html", "2 Function basics 2.1 Definition and execution 2.2 Arguments 2.3 Use case: Intermediate variables 2.4 Default values 2.5 Multiple arguments 2.6 Argument matching", " 2 Function basics Structuring the code to avoid too much copy-pasting This chapter discusses functions as building blocks for more expressive and more powerful data analysis code. 2.1 Definition and execution The following packages are used for this chapter. library(tidyverse) library(here) Create functions for tasks that need to be executed repeatedly, or to hide implementation details. read_weather_data &lt;- function() { # Read all files berlin &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;berlin.xlsx&quot;)) toronto &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;toronto.xlsx&quot;)) tel_aviv &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;tel_aviv.xlsx&quot;)) zurich &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;zurich.xlsx&quot;)) # Create ensemble dataset weather_data &lt;- bind_rows( berlin = berlin, toronto = toronto, tel_aviv = tel_aviv, zurich = zurich, .id = &quot;city_code&quot; ) # Return it weather_data } Display the code of any function by writing its name without the subsequent parentheses: read_weather_data ## function() { ## # Read all files ## berlin &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;berlin.xlsx&quot;)) ## toronto &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;toronto.xlsx&quot;)) ## tel_aviv &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;tel_aviv.xlsx&quot;)) ## zurich &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;zurich.xlsx&quot;)) ## ## # Create ensemble dataset ## weather_data &lt;- bind_rows( ## berlin = berlin, ## toronto = toronto, ## tel_aviv = tel_aviv, ## zurich = zurich, ## .id = &quot;city_code&quot; ## ) ## ## # Return it ## weather_data ## } ## &lt;environment: 0x36a96e8&gt; Call the function by adding the parentheses: read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; Execution of the function does not create new variables in the global environment. The only object in the global environment is the function itself: ls() ## [1] &quot;read_weather_data&quot; A function can also be used as input for a pipe: read_weather_data() %&gt;% count(city_code) ## # A tibble: 4 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 toronto 49 ## 4 zurich 49 To reuse a function value, assign it to a variable: weather_data &lt;- read_weather_data() 2.1.1 Exercises Create a modified version of the function to return only data for Toronto and Tel Aviv. Call it. read_weather_data_non_europe &lt;- function() { _______ } _______ ## # A tibble: 98 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 toronto 2019-04-28 15:00:00 Partly… part… 0 ## 2 toronto 2019-04-28 16:00:00 Clear clea… 0 ## 3 toronto 2019-04-28 17:00:00 Clear clea… 0 ## # … with 95 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; Compute number of rows for Europe, count observations to validate: nrow(_____) - nrow(_____) ## [1] 98 2.2 Arguments Click here to show setup code. library(tidyverse) library(here) By adding arguments to your functions, you can turn them into tools for a wide range of applications. But it is advisable to be conservative here: try to minimise the number of arguments to the necessary ones, so the user has a clear and intuitive interface to deal with. Functions with arguments: weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } weather_path(&quot;milan.xlsx&quot;) ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/milan.xlsx&quot; Call functions from within functions: read_weather_data &lt;- function() { # Read all files berlin &lt;- readxl::read_excel(weather_path(&quot;berlin.xlsx&quot;)) toronto &lt;- readxl::read_excel(weather_path(&quot;toronto.xlsx&quot;)) tel_aviv &lt;- readxl::read_excel(weather_path(&quot;tel_aviv.xlsx&quot;)) zurich &lt;- readxl::read_excel(weather_path(&quot;zurich.xlsx&quot;)) # Create ensemble dataset weather_data &lt;- bind_rows( berlin = berlin, toronto = toronto, tel_aviv = tel_aviv, zurich = zurich, .id = &quot;city_code&quot; ) # Return it weather_data } The function still needs to be called for testing it. It is a good practice to always immediately test a the newly created or updated function by running it: read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 2.2.1 Exercises How does the behavior of read_weather_data() change if we update the definition of the read_weather() function as follows: weather_path &lt;- function(filename) { # Returned value here(&quot;data&quot;, &quot;weather&quot;, filename) } Hint: Define this function with a different name and check its output values, before running read_weather_data() again. 2.3 Use case: Intermediate variables Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } We start with the function weather_path() from section “Arguments”. Functions can help to avoid having to use intermediate variables: read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } read_weather_data &lt;- function() { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Return it weather_data } read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 2.3.1 Exercises Implement a helper function get_weather_file_for() that takes a city code as input and returns the file name for the corresponding Excel file. Intended usage: get_weather_file_for(&quot;berlin&quot;). Test this function on a few example inputs. get_weather_file_for &lt;- _____ { paste0(city_code, &quot;.xlsx&quot;) } get_weather_file_for(&quot;munich&quot;) ## [1] &quot;munich.xlsx&quot; get_weather_file_for(&quot;san_diego&quot;) ## [1] &quot;san_diego.xlsx&quot; Implement a helper function get_weather_data_for() that takes a city code as input (as opposed to a file name). Intended usage: get_weather_data_for(&quot;berlin&quot;). Update read_weather_data() to use get_weather_data_for(). get_weather_data_for &lt;- _____ { read_weather_file(_____) } get_weather_data_for(&quot;toronto&quot;) ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; 2.4 Default values Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } get_weather_file_for &lt;- function(city_code) { paste0(city_code, &quot;.xlsx&quot;) } get_weather_data_for &lt;- function(city_code) { read_weather_file(get_weather_file_for(city_code)) } For user-friendliness it is often good practice to provide default values for parameters We start with the functionget_weather_data_for() from section “Intermediate variables”. Here an example of a boolean argument which when TRUE leads to dropping the data about Zurich. read_weather_data &lt;- function(omit_zurich = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = get_weather_data_for(&quot;berlin&quot;), toronto = get_weather_data_for(&quot;toronto&quot;), tel_aviv = get_weather_data_for(&quot;tel_aviv&quot;), zurich = get_weather_data_for(&quot;zurich&quot;), .id = &quot;city_code&quot; ) # Return it (filtered) weather_data %&gt;% filter( !(city_code == &quot;zurich&quot; &amp; omit_zurich) ) } Set arguments with default values explicitly with or without using the name or leave them out to use the default value: read_weather_data(TRUE) ## # A tibble: 147 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 144 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; read_weather_data(omit_zurich = TRUE) ## # A tibble: 147 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 144 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 2.4.1 Exercises Update get_weather_data_for() to return Zurich data if called without arguments. Is this a good idea? get_weather_data_for &lt;- _____ { _____ } get_weather_data_for() %&gt;% select(temperature) ## # A tibble: 49 x 1 ## temperature ## &lt;dbl&gt; ## 1 6.96 ## 2 7.14 ## 3 7.32 ## # … with 46 more rows get_weather_data_for(&quot;tel_aviv&quot;) %&gt;% select(temperature) ## # A tibble: 49 x 1 ## temperature ## &lt;dbl&gt; ## 1 23.9 ## 2 23.1 ## 3 22.4 ## # … with 46 more rows 2.5 Multiple arguments Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } get_weather_file_for &lt;- function(city_code) { paste0(city_code, &quot;.xlsx&quot;) } get_weather_data_for &lt;- function(city_code) { read_weather_file(get_weather_file_for(city_code)) } We start once more with the functions weather_path() from section “Arguments” and get_weather_data_for() from section “Intermediate variables”. What are the considerations when using multiple function arguments? You can add new parameters in a very straightforward manner like this: read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = get_weather_data_for(&quot;berlin&quot;), toronto = get_weather_data_for(&quot;toronto&quot;), tel_aviv = get_weather_data_for(&quot;tel_aviv&quot;), zurich = get_weather_data_for(&quot;zurich&quot;), .id = &quot;city_code&quot; ) # Return it (filtered) weather_data %&gt;% filter( !(city_code == &quot;zurich&quot; &amp; omit_zurich) ) %&gt;% filter( !(city_code == &quot;toronto&quot; &amp; omit_toronto) ) } Prefer passing arguments by name rather than only giving the value, especially if the intent of the value is not clear from just reading it. # Good: read_weather_data(omit_zurich = TRUE) ## # A tibble: 147 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 144 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; read_weather_data(omit_toronto = TRUE) ## # A tibble: 147 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 144 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; # Bad: read_weather_data(TRUE) ## # A tibble: 147 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 144 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; Use the so called ellipsis (...) when you want to provide the possibility for the user to call your function with a list of arguments of unspecified length. This can be e.g. useful for passing arguments downstream: weather_path &lt;- function(...) { # All arguments are passed on here(&quot;data/weather&quot;, ...) } weather_path(&quot;berlin.xlsx&quot;) ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; weather_path(&quot;some&quot;, &quot;subdir&quot;, &quot;with&quot;, &quot;a&quot;, &quot;file.csv&quot;) ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/some/subdir/with/a/file.csv&quot; Mind, that despite altering the original function and adding new features to it, the original call still works as before: read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly… part… 0 ## 2 berlin 2019-04-28 16:00:00 Mostly… part… 0 ## 3 berlin 2019-04-28 17:00:00 Mostly… part… 0 ## # … with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 2.5.1 Exercises What does the following return? Why? read_weather_data(TRUE, omit_z = FALSE) %&gt;% count(city_code) See the next section for ideas on avoiding this behavior. 2.6 Argument matching Click here to show setup code. How does R handle function calls with arguments? Named arguments are assigned first, after that remaining slots are filled from left to right. use_names &lt;- function(one = 1, two = 2) { list(one = one, two = two) } use_names(3, 4) ## $one ## [1] 3 ## ## $two ## [1] 4 use_names(one = 3, 4) ## $one ## [1] 3 ## ## $two ## [1] 4 use_names(3, one = 4) ## $one ## [1] 4 ## ## $two ## [1] 3 use_names(one = 3, two = 4) ## $one ## [1] 3 ## ## $two ## [1] 4 use_names(two = 3, one = 4) ## $one ## [1] 4 ## ## $two ## [1] 3 Arguments are matched partially, which can be convenient but is also a source of errors. use_names(o = 3, 4) ## $one ## [1] 3 ## ## $two ## [1] 4 use_names(3, o = 4) ## $one ## [1] 4 ## ## $two ## [1] 3 use_names(o = 3, t = 4) ## $one ## [1] 3 ## ## $two ## [1] 4 use_names(t = 3, o = 4) ## $one ## [1] 4 ## ## $two ## [1] 3 The ellipsis can be used to enforce the user to fully name the function parameters when setting them: only_names &lt;- function(..., one = 1, two = 2) { list(one = one, two = two) } only_names(3, 4) ## $one ## [1] 1 ## ## $two ## [1] 2 only_names(one = 3, 4) ## $one ## [1] 3 ## ## $two ## [1] 2 only_names(one = 3, two = 4) ## $one ## [1] 3 ## ## $two ## [1] 4 only_names(o = 3, t = 4) ## $one ## [1] 1 ## ## $two ## [1] 2 Inside a function with an ellipsis as a parameter, you can capture the ellipsis with list(): ellipsis_test &lt;- function(...) { args &lt;- list(...) names(args) } ellipsis_test(a = 1, 2, c = 3:5) ## [1] &quot;a&quot; &quot;&quot; &quot;c&quot; Arguments in ellipsis can be accessed with ..1, ..2 etc. ellipsis_direct_test &lt;- function(...) { list(..1, ..2) } ellipsis_direct_test(a = 1, 2, c = 3:5) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 2.6.1 Exercises Naming, not naming or partly naming parameters in functions calls? What does the following return and why? use_some_names &lt;- function(one = 1, ..., two = 2) { list(one = one, two = two) } use_some_names(3, 4) use_some_names(one = 3, 4) use_some_names(3, one = 4) use_some_names(one = 3, two = 4) use_some_names(two = 4, 3) Model a new enforce_names() function after only_names() to check if any unnamed or misnamed arguments have been used. Test this function in various combinations. enforce_names &lt;- function(..., one = 1, two = 2) { extra_args &lt;- _____ stopifnot(length(_____) == 0) list(_____) } try(enforce_names(3, 4)) ## Error in enforce_names(3, 4) : length(extra_args) == 0 is not TRUE try(enforce_names(one = 3, 4)) ## Error in enforce_names(one = 3, 4) : length(extra_args) == 0 is not TRUE try(enforce_names(3, one = 4)) ## Error in enforce_names(3, one = 4) : length(extra_args) == 0 is not TRUE try(enforce_names(two = 4, 3)) ## Error in enforce_names(two = 4, 3) : length(extra_args) == 0 is not TRUE try(enforce_names(o = 3, t = 4)) ## Error in enforce_names(o = 3, t = 4) : ## length(extra_args) == 0 is not TRUE enforce_names(one = 3, two = 4) ## $one ## [1] 3 ## ## $two ## [1] 4 "],
["simple-iteration.html", "3 Simple iteration 3.1 Vectors and columns 3.2 Named vectors and two-column tibbles 3.3 Indexing/subsetting 3.4 Construction 3.5 Processing multiple files 3.6 Manipulating all datasets 3.7 Typed output", " 3 Simple iteration Processing multiple files that contain different parts of the same dataset This chapter introduces iteration as a concept to repeat the same operation over a sequence of inputs. It is largely independent of the previous chapter. The following packages are required throughout this chapter: library(tidyverse) library(here) 3.1 Vectors and columns So far we focus on the data frame, or tibble, as primary object for data analysis. Internally, a tibble is a list of vectors of the same length. Accessing a row in a tibble requires finding the same index in that list of vectors. Here we explore the relationship between columns of data frames and their corresponding vectors, i.e. the answer to “how to get from one to the other?”: We can e.g. get a vector with the files in a specific directory of our current project2 like this: files &lt;- dir(here(&quot;data/weather&quot;), full.names = TRUE) files ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; You can create a tibble from it using tibble::enframe(): files_df &lt;- files %&gt;% enframe() files_df ## # A tibble: 4 x 2 ## name value ## &lt;int&gt; &lt;chr&gt; ## 1 1 /home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx ## 2 2 /home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx ## 3 3 /home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx ## 4 4 /home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx The name column might be unwanted in some cases. Suppress its creation by setting name = NULL: files_df_1 &lt;- files %&gt;% enframe(name = NULL) files_df_1 ## # A tibble: 4 x 1 ## value ## &lt;chr&gt; ## 1 /home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx ## 2 /home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx ## 3 /home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx ## 4 /home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx Another way to create a tibble from a vector is using tibble::tibble(). You can name the newly created columns by assigning the vectors they are created from to (quoted or unquoted) column names: tibble(filename = files) ## # A tibble: 4 x 1 ## filename ## &lt;chr&gt; ## 1 /home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx ## 2 /home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx ## 3 /home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx ## 4 /home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx The other direction – producing a vector from a tibble column – works with dplyr::pull(). By default pull() will turn the rightmost column into a vector and ignore the rest of the tibble: files_df %&gt;% pull() ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; Turn a specific column into a vector by providing the desired column name to pull(), either quoted or unquoted: files_df %&gt;% pull(name) ## [1] 1 2 3 4 3.1.1 Exercises Investigate the output of fs::dir_ls() with enframe(). Explain. # install.packages(&quot;fs&quot;) fs::dir_ls() fs::dir_ls() %&gt;% ___() ## # A tibble: 45 x 2 ## name value ## &lt;chr&gt; &lt;fs::path&gt; ## 1 1.Rmd 1.Rmd ## 2 12-intro.Rmd 12-intro.Rmd ## 3 2.Rmd 2.Rmd ## # … with 42 more rows 3.2 Named vectors and two-column tibbles Click here to show setup code. library(tidyverse) library(here) Here we look at tidyverse-functions to work with named vectors and tibbles with more columns and the relations netween the two. As seen in section “Data”, load a table – here a dictionary detailing information related to an id-like name – from an MS Excel file with readxl::read_excel(): dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) dict ## # A tibble: 4 x 5 ## city_code weather_filename name lng lat ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 berlin data/weather/berlin.xlsx Berlin 13.4 52.5 ## 2 toronto data/weather/toronto.xlsx Toronto -79.4 43.7 ## 3 tel_aviv data/weather/tel_aviv.xlsx Tel Aviv 34.8 32.1 ## 4 zurich data/weather/zurich.xlsx Zürich 8.54 47.4 Use pull() as seen in the last chapter: dict %&gt;% pull(weather_filename) ## [1] &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; ## [3] &quot;data/weather/tel_aviv.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; Create absolute paths using here::here(): dict %&gt;% pull(weather_filename) %&gt;% here() ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; Produce a named vector with tibble::deframe(), which is thought as the inverse function to enframe(). When given a 2-column tibble, deframe() will by default use the first column for the names and the second column for the values of the resulting vector. When given a 1-column tibble, it creates an unnamed vector. When given a more-than-2-column tibble, it will use the first two columns as name- and value-columns for the resulting vector, ignore the rest and in addition give a warning that it expects a one- or two-column data frame. weather_filenames &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() weather_filenames ## berlin toronto ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; ## tel_aviv zurich ## &quot;data/weather/tel_aviv.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; The names() function accesses the names of a vector: weather_filenames %&gt;% names() ## [1] &quot;berlin&quot; &quot;toronto&quot; &quot;tel_aviv&quot; &quot;zurich&quot; Some operations producing vectors from vectors cause the names to be lost: paste0(&quot;&#39;&quot;, weather_filenames, &quot;&#39;&quot;) ## [1] &quot;&#39;data/weather/berlin.xlsx&#39;&quot; &quot;&#39;data/weather/toronto.xlsx&#39;&quot; ## [3] &quot;&#39;data/weather/tel_aviv.xlsx&#39;&quot; &quot;&#39;data/weather/zurich.xlsx&#39;&quot; weather_filenames %&gt;% here() ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; A possible solution can be in many cases to change the order of the transformations, so that the creation of the named vector comes last (or at least later): dict %&gt;% mutate(weather_filename_here = here(weather_filename)) ## # A tibble: 4 x 6 ## city_code weather_filename name lng lat weather_filename_here ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 berlin data/weather/berl… Berlin 13.4 52.5 /home/travis/build/krlm… ## 2 toronto data/weather/toro… Toron… -79.4 43.7 /home/travis/build/krlm… ## 3 tel_aviv data/weather/tel_… Tel A… 34.8 32.1 /home/travis/build/krlm… ## 4 zurich data/weather/zuri… Zürich 8.54 47.4 /home/travis/build/krlm… dict %&gt;% mutate(weather_filename_here = here(weather_filename)) %&gt;% select(city_code, weather_filename_here) ## # A tibble: 4 x 2 ## city_code weather_filename_here ## &lt;chr&gt; &lt;chr&gt; ## 1 berlin /home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx ## 2 toronto /home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx ## 3 tel_aviv /home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx ## 4 zurich /home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx dict %&gt;% mutate(weather_filename_here = here(weather_filename)) %&gt;% select(city_code, weather_filename_here) %&gt;% deframe() ## berlin ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## toronto ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## tel_aviv ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## zurich ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; 3.2.1 Exercises Obtain a mapping between city code and city name as a named vector. dict %&gt;% select(___, ___) %&gt;% deframe() ## berlin toronto tel_aviv zurich ## &quot;Berlin&quot; &quot;Toronto&quot; &quot;Tel Aviv&quot; &quot;Zürich&quot; Convert the output of fs::dir_info() to that seen from fs::dir_ls(). How do you make sure that the vector is named? # install.packages(&quot;fs&quot;) fs::dir_info() fs::dir_info() %&gt;% pull(___) fs::dir_info() %&gt;% select(_____, _____) %&gt;% ___() ## # A tibble: 45 x 18 ## path type size permissions modification_time user group ## &lt;fs::path&gt; &lt;fct&gt; &lt;fs::b&gt; &lt;fs::perms&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1.Rmd file 56 rw-rw-r-- 2019-05-29 19:54:06 trav… trav… ## 2 12-intro.… file 5.85K rw-rw-r-- 2019-05-29 19:54:06 trav… trav… ## 3 2.Rmd file 370 rw-rw-r-- 2019-05-29 19:54:06 trav… trav… ## # … with 42 more rows, and 11 more variables: device_id &lt;dbl&gt;, ## # hard_links &lt;dbl&gt;, special_device_id &lt;dbl&gt;, inode &lt;dbl&gt;, ## # block_size &lt;dbl&gt;, blocks &lt;dbl&gt;, flags &lt;int&gt;, generation &lt;dbl&gt;, ## # access_time &lt;dttm&gt;, change_time &lt;dttm&gt;, birth_time &lt;dttm&gt; ## 1.Rmd 12-intro.Rmd 2.Rmd ## 21-function.Rmd 22-args.Rmd 23-intermediate.Rmd ## 24-args-default.Rmd 25-args-multi.Rmd 26-args-matching.Rmd ## 3.Rmd 31-dir.Rmd 32-names.Rmd ## 33-index.Rmd 34-construct.Rmd 35-map.Rmd ## 36-map-manip.Rmd 37-map-type.Rmd 4.Rmd ## 41-map2.Rmd 42-mutate-map.Rmd ## 1.Rmd 12-intro.Rmd 2.Rmd ## 21-function.Rmd 22-args.Rmd 23-intermediate.Rmd ## 24-args-default.Rmd 25-args-multi.Rmd 26-args-matching.Rmd ## 3.Rmd 31-dir.Rmd 32-names.Rmd ## 33-index.Rmd 34-construct.Rmd 35-map.Rmd ## 36-map-manip.Rmd 37-map-type.Rmd 4.Rmd ## 41-map2.Rmd 42-mutate-map.Rmd 3.3 Indexing/subsetting Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) Here we look at the indexing of a named vector (works equivalently for a named list). We start with the data frame dict from section “Named vectors and two-column tibbles”. Create named vector of the – future – input files: input_files &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() input_files ## berlin toronto ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; ## tel_aviv zurich ## &quot;data/weather/tel_aviv.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; names(input_files) ## [1] &quot;berlin&quot; &quot;toronto&quot; &quot;tel_aviv&quot; &quot;zurich&quot; There are different ways of accessing individual entries of the named vector: input_files[1] ## berlin ## &quot;data/weather/berlin.xlsx&quot; input_files[[1]] ## [1] &quot;data/weather/berlin.xlsx&quot; input_files[&quot;berlin&quot;] ## berlin ## &quot;data/weather/berlin.xlsx&quot; input_files[[&quot;berlin&quot;]] ## [1] &quot;data/weather/berlin.xlsx&quot; Choose multiple entries with: input_files[1:2] ## berlin toronto ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; input_files[c(&quot;berlin&quot;, &quot;zurich&quot;)] ## berlin zurich ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; Consistent pipe-friendly access of single elements: input_files %&gt;% pluck(1) ## [1] &quot;data/weather/berlin.xlsx&quot; input_files %&gt;% pluck(&quot;berlin&quot;) ## [1] &quot;data/weather/berlin.xlsx&quot; 3.3.1 Exercises Explain the difference between [ and [[ subsetting. Implement a variant of subsetting in “tibble-land” with a combination of enframe(), slice() or filter(), and deframe(): input_files %&gt;% enframe() %&gt;% ___(_____) %&gt;% deframe() ## toronto ## &quot;data/weather/toronto.xlsx&quot; 3.4 Construction Click here to show setup code. The c() function constructs vectors. All elements of a vector must have the same type. c(1, 2, 3) ## [1] 1 2 3 c(1:3, 5) ## [1] 1 2 3 5 c(1:3, &quot;5&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;5&quot; Lists are constructed with list(). They are a special type of vector – they can contain elements of different type and length. list(1, 2, 3) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 list(1:3, 5) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 5 list(1:3, &quot;5&quot;) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;5&quot; Lists can also contain other lists. nested &lt;- list( 1:3, list(4, &quot;5&quot;), list( list(letters[6:8]), 9 ) ) nested ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [[2]][[1]] ## [1] 4 ## ## [[2]][[2]] ## [1] &quot;5&quot; ## ## ## [[3]] ## [[3]][[1]] ## [[3]][[1]][[1]] ## [1] &quot;f&quot; &quot;g&quot; &quot;h&quot; ## ## ## [[3]][[2]] ## [1] 9 str(nested) ## List of 3 ## $ : int [1:3] 1 2 3 ## $ :List of 2 ## ..$ : num 4 ## ..$ : chr &quot;5&quot; ## $ :List of 2 ## ..$ :List of 1 ## .. ..$ : chr [1:3] &quot;f&quot; &quot;g&quot; &quot;h&quot; ## ..$ : num 9 Vectors (and also lists) can have names. c(a = 1, b = 2, c = 3) ## a b c ## 1 2 3 list(a = 1:3, b = 5) ## $a ## [1] 1 2 3 ## ## $b ## [1] 5 rlang::set_names(1:3, letters[1:3]) ## a b c ## 1 2 3 The new {vctrs} package defines a data type for lists where all elements have the same type: a stricter list, but more powerful than a bare vector. #vctrs::list_of(1, 2, 3) #try(vctrs::list_of(1, 2, &quot;3&quot;)) #vctrs::list_of(letters[1:3], &quot;e&quot;) 3.4.1 Exercises Explain the differences between the outputs below. c(a = list(1:3), b = list(4:5)) ## $a ## [1] 1 2 3 ## ## $b ## [1] 4 5 list(a = list(1:3), b = list(4:5)) ## $a ## $a[[1]] ## [1] 1 2 3 ## ## ## $b ## $b[[1]] ## [1] 4 5 3.5 Processing multiple files Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_files &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() Here we look at how to act on each entry of a list or a vector using purrr::map(): We start with the named vector input_files from section “Indexing”. As just seen, manually choosing just one entry of a vector works like so: input_files[[1]] ## [1] &quot;data/weather/berlin.xlsx&quot; here(input_files[[1]]) ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; readxl::read_excel(here(input_files[[1]])) ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; However, if we try to read all files from the vector with read_excel(), this fails: here(input_files) ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; try(readxl::read_excel(here(input_files))) ## Error : `path` must be a string Unlike here(), the read_excel() function can process only one file at a time. We need to iterate explicitly. With map(), you can successively work through the whole vector and each time let the same function deal with the respective entry. The output of map() is a list where each element contains one results. The list is named if the input is named: input_data &lt;- map(input_files, ~ readxl::read_excel(here(.))) The map() call above is equivalent to the following code: input_data &lt;- list( berlin = readxl::read_excel(here(input_files[[1]])), toronto = readxl::read_excel(here(input_files[[2]])), tel_aviv = readxl::read_excel(here(input_files[[3]])), zurich = readxl::read_excel(here(input_files[[4]])) ) Let’s take a closer look at what we produced: input_data ## $berlin ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## $zurich ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0.267 0.28 ## 2 2019-04-28 16:00:00 Mostly… part… 0.198 0.27 ## 3 2019-04-28 17:00:00 Mostly… part… 0.137 0.25 ## # … with 46 more rows, and 13 more variables: precipType &lt;chr&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt; input_data[[1]] ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; names(input_data) ## [1] &quot;berlin&quot; &quot;toronto&quot; &quot;tel_aviv&quot; &quot;zurich&quot; map() can be included in your pipe in the following way: input_files %&gt;% map(~ readxl::read_excel(here(.))) ## $berlin ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## $zurich ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0.267 0.28 ## 2 2019-04-28 16:00:00 Mostly… part… 0.198 0.27 ## 3 2019-04-28 17:00:00 Mostly… part… 0.137 0.25 ## # … with 46 more rows, and 13 more variables: precipType &lt;chr&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt; 3.5.1 Exercises Read only the data for Toronto and Tel Aviv, using subsetting or filter(). Compare. input_files[_____] %&gt;% map(~ readxl::read_excel(here(.))) input_files %&gt;% ___() %&gt;% filter(name %in% c(_____)) %&gt;% ___() %&gt;% map(~ readxl::read_excel(here(.))) ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; Compute the absolute file name with here() outside of the map() call. input_files %&gt;% enframe() %&gt;% ___(_____) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(.)) ## $berlin ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## $zurich ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0.267 0.28 ## 2 2019-04-28 16:00:00 Mostly… part… 0.198 0.27 ## 3 2019-04-28 17:00:00 Mostly… part… 0.137 0.25 ## # … with 46 more rows, and 13 more variables: precipType &lt;chr&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt; Can you explain what happens when you call enframe() on the result? input_files %&gt;% map(~ readxl::read_excel(here(.))) %&gt;% enframe() 3.6 Manipulating all datasets Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) How to selectively manipulate specific parts of a list of datasets? We start with the named list of tibbles called input_data from section “Processing all files”. Of each tibble we only want the column time and all the columns whose name contains “emperature”. We test with the first entry: input_data[[1]] %&gt;% select(time, contains(&quot;emperature&quot;)) ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 13.4 13.4 ## 2 2019-04-28 16:00:00 13.6 13.6 ## 3 2019-04-28 17:00:00 14.1 14.1 ## # … with 46 more rows To apply this on all entries, we use map() again. Note that we need an explicit dot (.) in the select() call here, to indicate the position where each sub-dataset will be plugged in. input_data %&gt;% map(~ select(., time, contains(&quot;emperature&quot;))) ## $berlin ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 13.4 13.4 ## 2 2019-04-28 16:00:00 13.6 13.6 ## 3 2019-04-28 17:00:00 14.1 14.1 ## # … with 46 more rows ## ## $toronto ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 7.46 3.96 ## 2 2019-04-28 16:00:00 8.17 5.04 ## 3 2019-04-28 17:00:00 8.82 6.52 ## # … with 46 more rows ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # … with 46 more rows ## ## $zurich ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 6.96 3.89 ## 2 2019-04-28 16:00:00 7.14 4.33 ## 3 2019-04-28 17:00:00 7.32 5.41 ## # … with 46 more rows We can extend this to preserve only the observations with temperature greater or equal than 14°C: input_data %&gt;% map(~ select(., time, contains(&quot;emperature&quot;))) %&gt;% map(~ filter(., temperature &gt;= 14)) ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # … with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # … with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # … with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 Create a custom function for that specific purpose in a call to map(): find_good_times &lt;- function(data) { data %&gt;% select(time, contains(&quot;emperature&quot;)) %&gt;% filter(temperature &gt;= 14) } Let’s look at the object manipulator, that we created: find_good_times ## function(data) { ## data %&gt;% ## select(time, contains(&quot;emperature&quot;)) %&gt;% ## filter(temperature &gt;= 14) ## } ## &lt;environment: 0x36a96e8&gt; See the “Function basics” chapter for a more extensive introduction to functions. Testing the function: find_good_times(input_data[[4]]) ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 Now let’s use map() to let our function act on the entire dataset: good_times &lt;- map(input_data, ~ find_good_times(.)) good_times ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # … with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # … with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # … with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 map() allows for the following shortcut notation for functions with one argument only: map(input_data, find_good_times) ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # … with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # … with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # … with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 3.6.1 Exercises Use summarize() to compute the mean temperature and humidity for each city during that period. input_data %&gt;% ___(~ ___(., mean(___), mean(___))) ## $berlin ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 12.5 0.634 ## ## $toronto ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 6.39 0.597 ## ## $tel_aviv ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 22.6 0.526 ## ## $zurich ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 7.15 0.776 Create a function to compute the daily mean of these values for each dataset: compute_daily_mean &lt;- ___(data) { data %&gt;% ___(as.Date(time)) %&gt;% ___(_____) %&gt;% ungroup() } input_data %&gt;% ___(___) ## $berlin ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 12.2 0.636 ## 2 2019-04-29 12.7 0.690 ## 3 2019-04-30 12.3 0.551 ## ## $toronto ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 8.96 0.398 ## 2 2019-04-29 5.84 0.554 ## 3 2019-04-30 5.76 0.774 ## ## $tel_aviv ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 21.9 0.542 ## 2 2019-04-29 23.6 0.477 ## 3 2019-04-30 21.7 0.591 ## ## $zurich ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 5.80 0.778 ## 2 2019-04-29 7.09 0.756 ## 3 2019-04-30 7.98 0.803 Use the dim() function to compute the dimensions of each sub-dataset. Then, use prod() to compute the number of cells. Discuss your observation. input_data %&gt;% _____ input_data %&gt;% _____ %&gt;% _____ ## $berlin ## [1] 49 18 ## ## $toronto ## [1] 49 18 ## ## $tel_aviv ## [1] 49 17 ## ## $zurich ## [1] 49 18 ## $berlin ## [1] 882 ## ## $toronto ## [1] 882 ## ## $tel_aviv ## [1] 833 ## ## $zurich ## [1] 882 Create four plots of humidity vs. pressure, one for each city. Use geom_path(), map temperature to the color aesthetic: create_plot &lt;- function(___) { ___ %&gt;% ggplot(aes(_____)) + geom_path() } ___ %&gt;% ___(___) ## $berlin ## ## $toronto ## ## $tel_aviv ## ## $zurich 3.7 Typed output Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) If we know, what the output of each function call in a map() sequence looks like, we can often call a sub-type of map() to produce a more condensed output. We start with the named list of tibbles called input_data from section “Processing all files”. We want to know the number of rows of each tibble in input_data: input_data %&gt;% map(~ nrow(.)) ## $berlin ## [1] 49 ## ## $toronto ## [1] 49 ## ## $tel_aviv ## [1] 49 ## ## $zurich ## [1] 49 Each time an integer is produced. Therefore we can call map_int(), to create a named integer vector: input_data %&gt;% map_int(~ nrow(.)) ## berlin toronto tel_aviv zurich ## 49 49 49 49 If the output is of type character, use map_chr(): input_data %&gt;% map_chr(~ nrow(.)) ## berlin toronto tel_aviv zurich ## &quot;49&quot; &quot;49&quot; &quot;49&quot; &quot;49&quot; input_data %&gt;% map_chr(~ as.character(nrow(.))) ## berlin toronto tel_aviv zurich ## &quot;49&quot; &quot;49&quot; &quot;49&quot; &quot;49&quot; There are sub-types of the map() function for each atomic type: integer: map_int() numeric (double-precision value): map_dbl() character (strings): map_chr() logical (flags): map_lgl() raw (bytes): map_raw() 3.7.1 Exercises Explain what happens if you try to use map_dbl() with the dim() output: input_data %&gt;% map_dbl(dim) Extract a concise version of the first temperature value for each dataset: input_data %&gt;% map(~ slice(., 1)) %&gt;% ___(~ pull(_____)) ## berlin toronto tel_aviv zurich ## 13.43 7.46 23.90 6.96 Use paste0() to build a textual description for the weather during the observed period in a function. Create a two-column tibble. summarize_weather &lt;- _____ { ___ %&gt;% ___( _____, _____, _____, summary = paste(rle(summary)$values, collapse = &quot;, then &quot;) ) } describe_weather &lt;- function(weather_summary) { weather_summary %&gt;% mutate( text = paste0( &quot;We had temperatures between &quot;, min_temp, &quot; and &quot;, max_temp, &quot; °C.&quot;, &quot;The average humidity was &quot;, round(mean_humidity * 100), &quot; %. &quot;, &quot;The weather was &quot;, summary, &quot;.&quot; ) ) %&gt;% pull() } input_data %&gt;% ___(___) %&gt;% ___(___) %&gt;% ___() ## # A tibble: 4 x 2 ## name value ## &lt;chr&gt; &lt;chr&gt; ## 1 berlin We had temperatures between 6.14 and 19.98 °C.The average humid… ## 2 toronto We had temperatures between 3.03 and 9.99 °C.The average humidi… ## 3 tel_aviv We had temperatures between 17.15 and 28.77 °C.The average humi… ## 4 zurich We had temperatures between 2.01 and 14.3 °C.The average humidi… function here::here() is taking care of making sure we start from the root directory of our current project↩ "],
["pairwise-iteration-and-nesting.html", "4 Pairwise iteration and nesting 4.1 Manipulating pairwise 4.2 Moving to tibble-land 4.3 Nesting and unnesting", " 4 Pairwise iteration and nesting This chapter explores iterating over pairs (or generally lists) of vectors of the same length. The relationship between vectors and data frame columns is especially helpful here, because values in one row of a tibble naturally correspond to accessing the same index in multiple vectors. This chapter uses the manipulated_data object from the “Manipulating all datasets” section. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) find_good_times &lt;- function(data) { data %&gt;% select(time, contains(&quot;emperature&quot;)) %&gt;% filter(temperature &gt;= 14) } good_times &lt;- input_data %&gt;% map(find_good_times) good_times ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # … with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # … with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # … with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 4.1 Manipulating pairwise Here we discuss cases when you want to iterate through two lists (of the same length) in parallel and use each value pair as two of the input parameters of a function. We first prepare a list of future output filenames: output_filenames &lt;- tempfile(names(good_times), fileext = &quot;.csv&quot;) output_filenames ## [1] &quot;/tmp/RtmpCquLue/berlin2db86db4890.csv&quot; ## [2] &quot;/tmp/RtmpCquLue/toronto2db85d48b7b5.csv&quot; ## [3] &quot;/tmp/RtmpCquLue/tel_aviv2db8616cda7.csv&quot; ## [4] &quot;/tmp/RtmpCquLue/zurich2db83741747a.csv&quot; We want to use readr::write_csv() to write each tibble into the respective file. write_csv() needs at least 2 arguments: the tibble itself and the path to the filename. For illustration, we implement a file-centric wrapper function that takes the file name as first argument and also prints a message every time a file is written. We use map2() to handle this: process_csv &lt;- function(file, data) { readr::write_csv(data, file) message(&quot;Writing &quot;, file) invisible(file) } map2(good_times, output_filenames, ~ process_csv(..2, ..1)) ## Writing /tmp/RtmpCquLue/berlin2db86db4890.csv ## Writing /tmp/RtmpCquLue/toronto2db85d48b7b5.csv ## Writing /tmp/RtmpCquLue/tel_aviv2db8616cda7.csv ## Writing /tmp/RtmpCquLue/zurich2db83741747a.csv ## $berlin ## [1] &quot;/tmp/RtmpCquLue/berlin2db86db4890.csv&quot; ## ## $toronto ## [1] &quot;/tmp/RtmpCquLue/toronto2db85d48b7b5.csv&quot; ## ## $tel_aviv ## [1] &quot;/tmp/RtmpCquLue/tel_aviv2db8616cda7.csv&quot; ## ## $zurich ## [1] &quot;/tmp/RtmpCquLue/zurich2db83741747a.csv&quot; invisible(map2(good_times, output_filenames, ~ process_csv(..2, ..1))) ## Writing /tmp/RtmpCquLue/berlin2db86db4890.csv ## Writing /tmp/RtmpCquLue/toronto2db85d48b7b5.csv ## Writing /tmp/RtmpCquLue/tel_aviv2db8616cda7.csv ## Writing /tmp/RtmpCquLue/zurich2db83741747a.csv Because process_csv() returns the file name, it is available as output. Since we are just interested in the side-effects of write_csv() and not in the displayed output, we can use the related function walk2(). walk2(good_times, output_filenames, ~ process_csv(..2, ..1)) ## Writing /tmp/RtmpCquLue/berlin2db86db4890.csv ## Writing /tmp/RtmpCquLue/toronto2db85d48b7b5.csv ## Writing /tmp/RtmpCquLue/tel_aviv2db8616cda7.csv ## Writing /tmp/RtmpCquLue/zurich2db83741747a.csv print(walk2(good_times, output_filenames, ~ process_csv(..2, ..1))) ## Writing /tmp/RtmpCquLue/berlin2db86db4890.csv ## Writing /tmp/RtmpCquLue/toronto2db85d48b7b5.csv ## Writing /tmp/RtmpCquLue/tel_aviv2db8616cda7.csv ## Writing /tmp/RtmpCquLue/zurich2db83741747a.csv ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # … with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # … with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # … with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 walk2() returns its first argument so that it can be used in a pipe. 4.1.1 Exercises What does the following code display? good_times %&gt;% walk2(output_filenames, ~ readr::write_csv(..1, ..2)) %&gt;% map_int(nrow) 4.2 Moving to tibble-land Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) find_good_times &lt;- function(data) { data %&gt;% select(time, contains(&quot;emperature&quot;)) %&gt;% filter(temperature &gt;= 14) } good_times &lt;- input_data %&gt;% map(find_good_times) How to combine the abilities of map() &amp; co., which work on vectors and lists, with our commonly used data structure, the tibble? We start with the named list of tibbles called input_data from section “Processing all files” and with dict from section “Named vectors and two-column tibbles”. Calling enframe() to produce a data frame from input_data leads to a maybe at first surprising, but oftentimes useful result: nested_input_data &lt;- input_data %&gt;% enframe() nested_input_data ## # A tibble: 4 x 2 ## name value ## &lt;chr&gt; &lt;list&gt; ## 1 berlin &lt;tibble [49 × 18]&gt; ## 2 toronto &lt;tibble [49 × 18]&gt; ## 3 tel_aviv &lt;tibble [49 × 17]&gt; ## 4 zurich &lt;tibble [49 × 18]&gt; This is because lists are also vectors. In our case each list entry contains a tibble, which can be “nested” into each entry of column value. Starting with the tibble dict we can see how dpylr::mutate() and map() can nicely work together to produce a somewhat similar result: dict %&gt;% select(city_code, weather_filename) %&gt;% mutate( data = map(weather_filename, ~ readxl::read_excel(here(.))) ) ## # A tibble: 4 x 3 ## city_code weather_filename data ## &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 berlin data/weather/berlin.xlsx &lt;tibble [49 × 18]&gt; ## 2 toronto data/weather/toronto.xlsx &lt;tibble [49 × 18]&gt; ## 3 tel_aviv data/weather/tel_aviv.xlsx &lt;tibble [49 × 17]&gt; ## 4 zurich data/weather/zurich.xlsx &lt;tibble [49 × 18]&gt; This works because R interprets columns of tibbles as vectors, which can be fed to map(). To simplify the map() call, we create an intermediate column: dict %&gt;% select(city_code, weather_filename) %&gt;% mutate(path = here(weather_filename)) %&gt;% mutate(data = map(path, readxl::read_excel)) ## # A tibble: 4 x 4 ## city_code weather_filename path data ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 berlin data/weather/berlin.… /home/travis/build/krlmlr/tid… &lt;tibble [… ## 2 toronto data/weather/toronto… /home/travis/build/krlmlr/tid… &lt;tibble [… ## 3 tel_aviv data/weather/tel_avi… /home/travis/build/krlmlr/tid… &lt;tibble [… ## 4 zurich data/weather/zurich.… /home/travis/build/krlmlr/tid… &lt;tibble [… Staying in “tibble-land” as long as possible helps retaining other important components of the data you are processing, so that you can keep using familiar data transformation tools. dict_data &lt;- dict %&gt;% mutate( data = map(weather_filename, ~ readxl::read_excel(here(.))), rows = map_int(data, nrow), ) %&gt;% select(-weather_filename) dict_data ## # A tibble: 4 x 6 ## city_code name lng lat data rows ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; &lt;int&gt; ## 1 berlin Berlin 13.4 52.5 &lt;tibble [49 × 18]&gt; 49 ## 2 toronto Toronto -79.4 43.7 &lt;tibble [49 × 18]&gt; 49 ## 3 tel_aviv Tel Aviv 34.8 32.1 &lt;tibble [49 × 17]&gt; 49 ## 4 zurich Zürich 8.54 47.4 &lt;tibble [49 × 18]&gt; 49 This pattern can also be used with the map2() family of functions: dict_data_with_desc &lt;- dict_data %&gt;% mutate( desc = map2_chr( name, rows, ~ paste0(..2, &quot; rows in data for &quot;, ..1) ) ) Because mutate() always appends to the end, the most recently added column can always be accessed with pull(): dict_data_with_desc %&gt;% pull() ## [1] &quot;49 rows in data for Berlin&quot; &quot;49 rows in data for Toronto&quot; ## [3] &quot;49 rows in data for Tel Aviv&quot; &quot;49 rows in data for Zürich&quot; More generally, pmap() supports functions with an arbitrary number of arguments: dict_data %&gt;% mutate( cols = map_int(data, ncol), desc = pmap_chr( list(name, rows, cols), ~ paste0(..2, &quot; rows and &quot;, ..3, &quot; cols in data for &quot;, ..1) ) ) ## # A tibble: 4 x 8 ## city_code name lng lat data rows cols desc ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 berlin Berlin 13.4 52.5 &lt;tibble [… 49 18 49 rows and 18 col… ## 2 toronto Toronto -79.4 43.7 &lt;tibble [… 49 18 49 rows and 18 col… ## 3 tel_aviv Tel Av… 34.8 32.1 &lt;tibble [… 49 17 49 rows and 17 col… ## 4 zurich Zürich 8.54 47.4 &lt;tibble [… 49 18 49 rows and 18 col… 4.2.1 Exercises The imap() family of functions iterates over a vector and its names: input_data %&gt;% imap_chr(~ paste0(.y, &quot;: &quot;, nrow(.x), &quot; rows&quot;)) ## berlin toronto tel_aviv ## &quot;berlin: 49 rows&quot; &quot;toronto: 49 rows&quot; &quot;tel_aviv: 49 rows&quot; ## zurich ## &quot;zurich: 49 rows&quot; Implement the same functionality using map2() inside a mutate(), and enframe(): good_times %&gt;% ___() %&gt;% mutate(___ = map2()) %&gt;% deframe() 4.3 Nesting and unnesting Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) dict_data &lt;- dict %&gt;% mutate(data = map(weather_filename, ~ readxl::read_excel(here(.)))) %&gt;% select(-weather_filename) How to work with nested data? We start with the tibble dict_data from section “Moving to tibble-land”, which includes the nested tibbles in its column data. If we want to actually look at the data we can directly use tidyr::unnest() on the whole tibble, which by default acts on all list-columns. This expands our tibble by repeating the formerly unnested column entries as many times, as each nested tibble has rows: dict_data %&gt;% unnest() ## # A tibble: 196 x 22 ## city_code name lng lat time summary icon ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 berlin Berl… 13.4 52.5 2019-04-28 15:00:00 Mostly… part… ## 2 berlin Berl… 13.4 52.5 2019-04-28 16:00:00 Mostly… part… ## 3 berlin Berl… 13.4 52.5 2019-04-28 17:00:00 Mostly… part… ## # … with 193 more rows, and 15 more variables: precipIntensity &lt;dbl&gt;, ## # precipProbability &lt;dbl&gt;, temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, ## # dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, ## # windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, ## # visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, precipType &lt;chr&gt; This is very similar to bind_rows() of the data column. dict_data %&gt;% pull(data) %&gt;% bind_rows() ## # A tibble: 196 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 193 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; check_columns_same &lt;- function(x, y) { stopifnot(identical(colnames(x), colnames(y))) } bind_rows &lt;- function(data_frames) { # Called for the side effect reduce(data_frames, check_columns_same) dplyr::bind_rows(data_frames) } try( dict_data %&gt;% pull(data) %&gt;% bind_rows() ) ## Error in fn(out, elt, ...) : ## identical(colnames(x), colnames(y)) is not TRUE Data flattened in this way is useful if the parts can be combined naturally into a larger dataset. Iterating over columns in the nested view corresponds to grouped operations in the flat view. dict_data %&gt;% mutate(n = map_int(data, nrow)) %&gt;% select(-data) ## # A tibble: 4 x 5 ## city_code name lng lat n ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 berlin Berlin 13.4 52.5 49 ## 2 toronto Toronto -79.4 43.7 49 ## 3 tel_aviv Tel Aviv 34.8 32.1 49 ## 4 zurich Zürich 8.54 47.4 49 dict_data %&gt;% unnest() %&gt;% count(name) ## # A tibble: 4 x 2 ## name n ## &lt;chr&gt; &lt;int&gt; ## 1 Berlin 49 ## 2 Tel Aviv 49 ## 3 Toronto 49 ## 4 Zürich 49 Inversely, if you want to have a more condensed view of your data, you can nest again. By default, the function tidyr::nest() will nest all data. Therefore it is often useful to tell it, which columns to ignore: dict_data %&gt;% unnest() %&gt;% nest(-city_code, -name, -lng, -lat) ## # A tibble: 4 x 5 ## city_code name lng lat data ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 berlin Berlin 13.4 52.5 &lt;tibble [49 × 18]&gt; ## 2 toronto Toronto -79.4 43.7 &lt;tibble [49 × 18]&gt; ## 3 tel_aviv Tel Aviv 34.8 32.1 &lt;tibble [49 × 18]&gt; ## 4 zurich Zürich 8.54 47.4 &lt;tibble [49 × 18]&gt; Using this, we structure our data in new, customized ways. For processing of daily data over all cities, we create a new column date: dict_data %&gt;% unnest() %&gt;% mutate(date = as.Date(time)) %&gt;% nest(-date) ## # A tibble: 3 x 2 ## date data ## &lt;date&gt; &lt;list&gt; ## 1 2019-04-28 &lt;tibble [36 × 22]&gt; ## 2 2019-04-29 &lt;tibble [96 × 22]&gt; ## 3 2019-04-30 &lt;tibble [64 × 22]&gt; 4.3.1 Exercises Implement the following code as a mapping over a nested tibble. Use a helper function: iris %&gt;% group_by(Species) %&gt;% summarize_all(list(Mean = mean)) %&gt;% ungroup() ## # A tibble: 3 x 5 ## Species Sepal.Length_Me… Sepal.Width_Mean Petal.Length_Me… ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 1.46 ## 2 versic… 5.94 2.77 4.26 ## 3 virgin… 6.59 2.97 5.55 ## # … with 1 more variable: Petal.Width_Mean &lt;dbl&gt; summarize_to_mean &lt;- function(data) { data %&gt;% ___(_____) } iris %&gt;% nest(___) %&gt;% mutate(data = map(___, summarize_to_mean)) %&gt;% unnest() When is a grouped operation preferable over nesting? Discuss. Data frames are lists under the hood. Explain the output of the following code. What use cases can you imagine? dict_data %&gt;% as.list() %&gt;% enframe() ## # A tibble: 5 x 2 ## name value ## &lt;chr&gt; &lt;list&gt; ## 1 city_code &lt;chr [4]&gt; ## 2 name &lt;chr [4]&gt; ## 3 lng &lt;dbl [4]&gt; ## 4 lat &lt;dbl [4]&gt; ## 5 data &lt;list [4]&gt; "],
["scoping-and-flow-control.html", "5 Scoping and flow control 5.1 Scope 5.2 Pure functions and side effects 5.3 Control flow 5.4 Closures", " 5 Scoping and flow control This chapter discusses a few details regarding functions. 5.1 Scope What happens if a function defines variables that have a variable by the same name in the global environment? We start with a variable defined in the global environment: a &lt;- 5 A function can access global variables: f &lt;- function() { a } f() ## [1] 5 On the other hand, a variable which is defined inside a function is contained in that function. It will not be known outside of that function. Respectively, it won’t overwrite the value of global variables. f &lt;- function() { a &lt;- 2 a } f() ## [1] 2 a ## [1] 5 Global variables are a (hidden) part of a function’s interface. Ideally, functions are be self-contained, independent of global variables. Notable exceptions are objects are used across your entire analysis, such as “the dataset”. (Otherwise you would need to pass them across many layers.) 5.1.1 Exercises Double-check what happens if two functions declare/use a variable of the same name. # Variables in different functions f1 &lt;- function() { a &lt;- 3 a + f2() } f2 &lt;- function() { a } f1() f2() a 5.2 Pure functions and side effects Click here to show setup code. library(tidyverse) Functions should do one thing, and do it well.3 A pure function is one that is called for its return value and which has no side effects: pure_function &lt;- function(x) { x + 1 } pure_function(1) ## [1] 2 For functions with side effect, it is good practice to return the input invisibly: side_effect_function &lt;- function(x) { file &lt;- tempfile() writeLines(format(x), tempfile()) print(x) message(x, &quot; written to &quot;, file) invisible(x) } side_effect_function(2) ## [1] 2 ## 2 written to /tmp/RtmpCquLue/file2db818c0ce09 Separation helps isolate the side effects. If side effect functions return the input, they remain composable with pure functions: 5 %&gt;% pure_function() %&gt;% side_effect_function() %&gt;% pure_function() ## [1] 6 ## 6 written to /tmp/RtmpCquLue/file2db81bfd1887 ## [1] 7 5.2.1 Exercises In the above example, which part of the pipe triggers the display of 6 and 7, respectively? How do you create a function that returns more than one value? Implement your own purely functional version of sum() by using reduce(). (Hint: `+` is a function that takes two arguments and returns the sum.) reduce(1:5, ___) ## [1] 15 Implement your own purely functional version of cumsum() by using accumulate(). accumulate(1:5, ___) ## [1] 1 3 6 10 15 Implement your own purely functional version of cumsum() by using reduce() only. (Hint: Use tail(., 1) to access the last element of a vector.) reduce(1:5, ~ _____) ## [1] 1 3 6 10 15 5.3 Control flow Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } We start once more with the functions weather_path() from section “Arguments” and read_weather_file() from section “Intermediate variables”. A way to regulate the control flow is by using if (): read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Filter, conditionally if (omit_zurich) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;zurich&quot;) } if (omit_toronto) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;toronto&quot;) } # Return result weather_data } read_weather_data(omit_toronto = TRUE, omit_zurich = TRUE) %&gt;% count(city_code) ## # A tibble: 2 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 read_weather_data(omit_toronto = TRUE, omit_zurich = FALSE) %&gt;% count(city_code) ## # A tibble: 3 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 zurich 49 This can be useful if aiming at a possible early return: read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Can keep original data? if (!omit_zurich &amp;&amp; !omit_toronto) { return(weather_data) } # Filter, conditionally if (omit_zurich) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;zurich&quot;) } if (omit_toronto) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;toronto&quot;) } # Return result weather_data } Conditional branching with if-else-logic. (This is just for illustration, you should not implement code like this!) read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Filter, conditionally, and return if (!omit_zurich &amp;&amp; !omit_toronto) { weather_data } else if (omit_zurich &amp;&amp; !omit_toronto) { weather_data %&gt;% filter(city_code != &quot;zurich&quot;) } else if (!omit_zurich &amp;&amp; omit_toronto) { weather_data %&gt;% filter(city_code != &quot;toronto&quot;) } else { # Filter both weather_data %&gt;% filter(city_code != &quot;zurich&quot;) %&gt;% filter(city_code != &quot;toronto&quot;) } } read_weather_data(omit_toronto = TRUE) %&gt;% count(city_code) ## # A tibble: 3 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 zurich 49 read_weather_data(omit_zurich = TRUE) %&gt;% count(city_code) ## # A tibble: 3 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 toronto 49 5.3.1 Exercises Implement a function that branches over an argument and returns the sum or the product of the input, respectively. agg &lt;- function(_____) { if (fun == &quot;___&quot;) { sum(x) } else if (_____) { prod(___) } else { rlang::abort(&#39;`fun` must be &quot;sum&quot; or &quot;prod&quot;.&#39;) } } agg(1:4, &quot;sum&quot;) ## [1] 10 agg(1:4, &quot;prod&quot;) ## [1] 24 5.4 Closures Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } get_weather_file_for &lt;- function(city_code) { paste0(city_code, &quot;.xlsx&quot;) } get_weather_data_for &lt;- function(city_code) { read_weather_file(get_weather_file_for(city_code)) } Closures can e.g. be used during function definition. We start once more with the functions weather_path() from section “Arguments” and read_weather_file() from section “Intermediate variables”. Here we create a function that loads a particular dataset: make_read_weather_file &lt;- function(filename) { # Avoid odd effects due to lazy evaluation force(filename) # This function (closure) accesses the filename from the # outer function f &lt;- function() { read_weather_file(filename) } f } read_berlin &lt;- make_read_weather_file(&quot;berlin.xlsx&quot;) read_toronto &lt;- make_read_weather_file(&quot;toronto.xlsx&quot;) read_tel_aviv &lt;- make_read_weather_file(&quot;tel_aviv.xlsx&quot;) read_zurich &lt;- make_read_weather_file(&quot;zurich.xlsx&quot;) read_berlin ## function() { ## read_weather_file(filename) ## } ## &lt;environment: 0x7a47180&gt; read_toronto ## function() { ## read_weather_file(filename) ## } ## &lt;environment: 0x78f2b18&gt; read_berlin() ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; read_toronto() ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; Use closures as wrappers for other verbs/functions (such functions are also called “adverbs”): loudly &lt;- function(f) { force(f) function(...) { args &lt;- list(...) msg &lt;- paste0(length(args), &quot; argument(s)&quot;) message(msg) f(...) } } read_loudly &lt;- loudly(read_weather_file) read_loudly ## function(...) { ## args &lt;- list(...) ## msg &lt;- paste0(length(args), &quot; argument(s)&quot;) ## message(msg) ## ## f(...) ## } ## &lt;environment: 0x7b40f88&gt; read_loudly(&quot;berlin.xlsx&quot;) ## 1 argument(s) ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; The safely() function is another example from the purrr package: cities &lt;- list(&quot;berlin&quot;, &quot;toronto&quot;, &quot;milan&quot;, &quot;tel_aviv&quot;) try(map(cities, get_weather_data_for)) ## Error : `path` does not exist: &#39;/home/travis/build/krlmlr/tidyprog/data/weather/milan.xlsx&#39; map(cities, safely(get_weather_data_for)) ## [[1]] ## [[1]]$result ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## [[1]]$error ## NULL ## ## ## [[2]] ## [[2]]$result ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## [[2]]$error ## NULL ## ## ## [[3]] ## [[3]]$result ## NULL ## ## [[3]]$error ## &lt;simpleError: `path` does not exist: '/home/travis/build/krlmlr/tidyprog/data/weather/milan.xlsx'&gt; ## ## ## [[4]] ## [[4]]$result ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## [[4]]$error ## NULL safely(get_weather_data_for) ## function (...) ## capture_error(.f(...), otherwise, quiet) ## &lt;bytecode: 0x93fe5d0&gt; ## &lt;environment: 0x9094e30&gt; map(cities, ~ safely(get_weather_data_for)(.)) ## [[1]] ## [[1]]$result ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## [[1]]$error ## NULL ## ## ## [[2]] ## [[2]]$result ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## [[2]]$error ## NULL ## ## ## [[3]] ## [[3]]$result ## NULL ## ## [[3]]$error ## &lt;simpleError: `path` does not exist: '/home/travis/build/krlmlr/tidyprog/data/weather/milan.xlsx'&gt; ## ## ## [[4]] ## [[4]]$result ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## [[4]]$error ## NULL safe_get_weather_data_for &lt;- safely(get_weather_data_for) map(cities, ~ safe_get_weather_data_for(.)) ## [[1]] ## [[1]]$result ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly… part… 0 0 ## 2 2019-04-28 16:00:00 Mostly… part… 0 0 ## 3 2019-04-28 17:00:00 Mostly… part… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## [[1]]$error ## NULL ## ## ## [[2]] ## [[2]]$result ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## [[2]]$error ## NULL ## ## ## [[3]] ## [[3]]$result ## NULL ## ## [[3]]$error ## &lt;simpleError: `path` does not exist: '/home/travis/build/krlmlr/tidyprog/data/weather/milan.xlsx'&gt; ## ## ## [[4]] ## [[4]]$result ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili… ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly… part… 0 0 ## 2 2019-04-28 16:00:00 Clear clea… 0 0 ## 3 2019-04-28 17:00:00 Clear clea… 0 0 ## # … with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## [[4]]$error ## NULL 5.4.1 Exercises Review the help and the implementation of safely() and possibly(). safely ## function (.f, otherwise = NULL, quiet = TRUE) ## { ## .f &lt;- as_mapper(.f) ## function(...) capture_error(.f(...), otherwise, quiet) ## } ## &lt;bytecode: 0x93fead8&gt; ## &lt;environment: namespace:purrr&gt; possibly ## function (.f, otherwise, quiet = TRUE) ## { ## .f &lt;- as_mapper(.f) ## force(otherwise) ## function(...) { ## tryCatch(.f(...), error = function(e) { ## if (!quiet) ## message(&quot;Error: &quot;, e$message) ## otherwise ## }, interrupt = function(e) { ## stop(&quot;Terminated by user&quot;, call. = FALSE) ## }) ## } ## } ## &lt;bytecode: 0x7c3b2e8&gt; ## &lt;environment: namespace:purrr&gt; Unix philosophy, originated by Ken Thompson↩ "],
["non-rectangular-data.html", "6 Non-rectangular data 6.1 Traversing 6.2 Iterating and traversing 6.3 Plucking multiple locations 6.4 Flattening 6.5 Transposing 6.6 Rectangling 6.7 Accessing APIs", " 6 Non-rectangular data working with raw data from online services (JSON) This chapter gives an example for processing deeply nested lists and converting them to data frames. 6.1 Traversing Click here to show setup code. library(tidyverse) library(here) We are now working with the results from downloading geolocation data from photon.komoot.de. This is stored in the file here(&quot;data/komoot-berlin.rds&quot;) and we can read it with readRDS(): berlin &lt;- readRDS(here(&quot;data/komoot-berlin.rds&quot;)) berlin ## $features ## $features[[1]] ## $features[[1]]$geometry ## $features[[1]]$geometry$coordinates ## $features[[1]]$geometry$coordinates[[1]] ## [1] 13.38886 ## ## $features[[1]]$geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## $features[[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[1]]$type ## [1] &quot;Feature&quot; ## ## $features[[1]]$properties ## $features[[1]]$properties$osm_id ## [1] 240109189 ## ## $features[[1]]$properties$osm_type ## [1] &quot;N&quot; ## ## $features[[1]]$properties$country ## [1] &quot;Germany&quot; ## ## $features[[1]]$properties$osm_key ## [1] &quot;place&quot; ## ## $features[[1]]$properties$city ## [1] &quot;Berlin&quot; ## ## $features[[1]]$properties$osm_value ## [1] &quot;city&quot; ## ## $features[[1]]$properties$postcode ## [1] &quot;10117&quot; ## ## $features[[1]]$properties$name ## [1] &quot;Berlin&quot; ## ## ## ## ## $type ## [1] &quot;FeatureCollection&quot; str(berlin) ## List of 2 ## $ features:List of 1 ## ..$ :List of 3 ## .. ..$ geometry :List of 2 ## .. .. ..$ coordinates:List of 2 ## .. .. .. ..$ : num 13.4 ## .. .. .. ..$ : num 52.5 ## .. .. ..$ type : chr &quot;Point&quot; ## .. ..$ type : chr &quot;Feature&quot; ## .. ..$ properties:List of 8 ## .. .. ..$ osm_id : int 240109189 ## .. .. ..$ osm_type : chr &quot;N&quot; ## .. .. ..$ country : chr &quot;Germany&quot; ## .. .. ..$ osm_key : chr &quot;place&quot; ## .. .. ..$ city : chr &quot;Berlin&quot; ## .. .. ..$ osm_value: chr &quot;city&quot; ## .. .. ..$ postcode : chr &quot;10117&quot; ## .. .. ..$ name : chr &quot;Berlin&quot; ## $ type : chr &quot;FeatureCollection&quot; As you can see it is a somewhat complex list structure. We know from “Indexing” that we can access it’s components in the following way: berlin$type ## [1] &quot;FeatureCollection&quot; berlin$features ## [[1]] ## [[1]]$geometry ## [[1]]$geometry$coordinates ## [[1]]$geometry$coordinates[[1]] ## [1] 13.38886 ## ## [[1]]$geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## [[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## [[1]]$type ## [1] &quot;Feature&quot; ## ## [[1]]$properties ## [[1]]$properties$osm_id ## [1] 240109189 ## ## [[1]]$properties$osm_type ## [1] &quot;N&quot; ## ## [[1]]$properties$country ## [1] &quot;Germany&quot; ## ## [[1]]$properties$osm_key ## [1] &quot;place&quot; ## ## [[1]]$properties$city ## [1] &quot;Berlin&quot; ## ## [[1]]$properties$osm_value ## [1] &quot;city&quot; ## ## [[1]]$properties$postcode ## [1] &quot;10117&quot; ## ## [[1]]$properties$name ## [1] &quot;Berlin&quot; berlin$features[[1]] ## $geometry ## $geometry$coordinates ## $geometry$coordinates[[1]] ## [1] 13.38886 ## ## $geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## $geometry$type ## [1] &quot;Point&quot; ## ## ## $type ## [1] &quot;Feature&quot; ## ## $properties ## $properties$osm_id ## [1] 240109189 ## ## $properties$osm_type ## [1] &quot;N&quot; ## ## $properties$country ## [1] &quot;Germany&quot; ## ## $properties$osm_key ## [1] &quot;place&quot; ## ## $properties$city ## [1] &quot;Berlin&quot; ## ## $properties$osm_value ## [1] &quot;city&quot; ## ## $properties$postcode ## [1] &quot;10117&quot; ## ## $properties$name ## [1] &quot;Berlin&quot; With the function purrr::pluck(), there is however a more universal tool available for accessing elements of more complex lists: berlin %&gt;% pluck(&quot;type&quot;) ## [1] &quot;FeatureCollection&quot; berlin[[&quot;type&quot;]] ## [1] &quot;FeatureCollection&quot; berlin %&gt;% pluck(&quot;features&quot;) ## [[1]] ## [[1]]$geometry ## [[1]]$geometry$coordinates ## [[1]]$geometry$coordinates[[1]] ## [1] 13.38886 ## ## [[1]]$geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## [[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## [[1]]$type ## [1] &quot;Feature&quot; ## ## [[1]]$properties ## [[1]]$properties$osm_id ## [1] 240109189 ## ## [[1]]$properties$osm_type ## [1] &quot;N&quot; ## ## [[1]]$properties$country ## [1] &quot;Germany&quot; ## ## [[1]]$properties$osm_key ## [1] &quot;place&quot; ## ## [[1]]$properties$city ## [1] &quot;Berlin&quot; ## ## [[1]]$properties$osm_value ## [1] &quot;city&quot; ## ## [[1]]$properties$postcode ## [1] &quot;10117&quot; ## ## [[1]]$properties$name ## [1] &quot;Berlin&quot; berlin %&gt;% pluck(&quot;features&quot;, 1) ## $geometry ## $geometry$coordinates ## $geometry$coordinates[[1]] ## [1] 13.38886 ## ## $geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## $geometry$type ## [1] &quot;Point&quot; ## ## ## $type ## [1] &quot;Feature&quot; ## ## $properties ## $properties$osm_id ## [1] 240109189 ## ## $properties$osm_type ## [1] &quot;N&quot; ## ## $properties$country ## [1] &quot;Germany&quot; ## ## $properties$osm_key ## [1] &quot;place&quot; ## ## $properties$city ## [1] &quot;Berlin&quot; ## ## $properties$osm_value ## [1] &quot;city&quot; ## ## $properties$postcode ## [1] &quot;10117&quot; ## ## $properties$name ## [1] &quot;Berlin&quot; berlin[[&quot;features&quot;]][[1]] ## $geometry ## $geometry$coordinates ## $geometry$coordinates[[1]] ## [1] 13.38886 ## ## $geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## $geometry$type ## [1] &quot;Point&quot; ## ## ## $type ## [1] &quot;Feature&quot; ## ## $properties ## $properties$osm_id ## [1] 240109189 ## ## $properties$osm_type ## [1] &quot;N&quot; ## ## $properties$country ## [1] &quot;Germany&quot; ## ## $properties$osm_key ## [1] &quot;place&quot; ## ## $properties$city ## [1] &quot;Berlin&quot; ## ## $properties$osm_value ## [1] &quot;city&quot; ## ## $properties$postcode ## [1] &quot;10117&quot; ## ## $properties$name ## [1] &quot;Berlin&quot; berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;) ## $coordinates ## $coordinates[[1]] ## [1] 13.38886 ## ## $coordinates[[2]] ## [1] 52.51704 ## ## ## $type ## [1] &quot;Point&quot; berlin[[&quot;features&quot;]][[1]][[&quot;geometry&quot;]] ## $coordinates ## $coordinates[[1]] ## [1] 13.38886 ## ## $coordinates[[2]] ## [1] 52.51704 ## ## ## $type ## [1] &quot;Point&quot; berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) ## [[1]] ## [1] 13.38886 ## ## [[2]] ## [1] 52.51704 Similarly: berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;properties&quot;, &quot;country&quot;) ## [1] &quot;Germany&quot; And as one more important characteristic of a tidyverse-function, pluck() is pipe-able: berlin %&gt;% pluck(&quot;features&quot;, 1) %&gt;% pluck(&quot;properties&quot;, &quot;country&quot;) ## [1] &quot;Germany&quot; 6.1.1 Exercises Introduce a variable for the first feature. Collect the coordinates, the country and the postal code. first_feature &lt;- berlin %&gt;% ___(_____) first_feature %&gt;% ___(_____) first_feature %&gt;% ___(_____) first_feature %&gt;% ___(_____) ## NULL ## [1] &quot;Germany&quot; ## [1] &quot;10117&quot; 6.2 Iterating and traversing Click here to show setup code. library(tidyverse) library(here) Now we are not only working with the geolocation data for Berlin, but we are adding data for our usual suspects: komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot ## # A tibble: 4 x 6 ## name url_name url res status content ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 Berlin Berlin https://photon.komoot.de/api/… &lt;respo… &lt;NULL&gt; &lt;list [… ## 2 Toronto Toronto https://photon.komoot.de/api/… &lt;respo… &lt;NULL&gt; &lt;list [… ## 3 Tel Av… Tel%20Aviv https://photon.komoot.de/api/… &lt;respo… &lt;NULL&gt; &lt;list [… ## 4 Zürich Z%C3%BCri… https://photon.komoot.de/api/… &lt;respo… &lt;NULL&gt; &lt;list [… It looks slightly different from the list berlin from section “Traversing”. That is because we have the list-of-2 stored for each city in the column content. By using pull() on content, we can produce a list containing the information for all cities: komoot_content &lt;- komoot %&gt;% pull(content) berlin &lt;- komoot_content %&gt;% pluck(1) berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) ## [[1]] ## [1] 13.38886 ## ## [[2]] ## [1] 52.51704 toronto &lt;- komoot_content %&gt;% pluck(2) toronto %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) ## [[1]] ## [1] -79.38721 ## ## [[2]] ## [1] 43.65396 With map() we can access the same element of the respective list for each city: komoot_content %&gt;% map(~ pluck(., &quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 With map() we can also use a shorthand notation for this, without the need to use pluck(). We can just give it a list of the arguments which we would normally use as arguments for pluck(): komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 The access path can also be stored in a variable: accessor &lt;- list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) coordinates &lt;- komoot_content %&gt;% map(accessor) coordinates ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 6.2.1 Exercises Augment komoot with a columns containing information on the first feature only. ## # A tibble: 4 x 7 ## name url_name url res status content first_feature ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 Berlin Berlin https://photon.kom… &lt;respo… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; ## 2 Toron… Toronto https://photon.kom… &lt;respo… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; ## 3 Tel A… Tel%20Av… https://photon.kom… &lt;respo… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; ## 4 Zürich Z%C3%BCr… https://photon.kom… &lt;respo… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; Augment komoot_first with columns containing information on coordinates, place and postal code. Use accessors and appropriate types for the columns. acc_coordinates &lt;- _____ acc_country &lt;- _____ komoot_first %&gt;% mutate( coordinates = ___(___, acc_coordinates), country = _____, postcode = map_chr(_____, ~ pluck(___, .default = NA)) ) ## # A tibble: 4 x 10 ## name url_name url res status content first_feature coordinates ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lis&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 Berl… Berlin http… &lt;res… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; &lt;NULL&gt; ## 2 Toro… Toronto http… &lt;res… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; &lt;NULL&gt; ## 3 Tel … Tel%20A… http… &lt;res… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; &lt;NULL&gt; ## 4 Züri… Z%C3%BC… http… &lt;res… &lt;NULL&gt; &lt;list … &lt;list [3]&gt; &lt;NULL&gt; ## # … with 2 more variables: country &lt;chr&gt;, postcode &lt;chr&gt; 6.3 Plucking multiple locations Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) What if we want to access two different pieces of information of each main list point at once? We are again starting in the setup with the list komoot_content from “Iterating and traversing”. Let’s define the two locations of the city-lists we would like to access: accessor_coords &lt;- list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) komoot_content %&gt;% map(accessor_coords) ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 accessor_country &lt;- list(&quot;features&quot;, 1, &quot;properties&quot;, &quot;country&quot;) komoot_content %&gt;% map(accessor_country) ## [[1]] ## [1] &quot;Germany&quot; ## ## [[2]] ## [1] &quot;Canada&quot; ## ## [[3]] ## [1] &quot;Israel&quot; ## ## [[4]] ## [1] &quot;Switzerland&quot; Combine them as a list of lists and hand it over to a map() inside a map(): accessors &lt;- list(coords = accessor_coords, country = accessor_country) accessors %&gt;% map(~ map(komoot_content, .)) ## $coords ## $coords[[1]] ## $coords[[1]][[1]] ## [1] 13.38886 ## ## $coords[[1]][[2]] ## [1] 52.51704 ## ## ## $coords[[2]] ## $coords[[2]][[1]] ## [1] -79.38721 ## ## $coords[[2]][[2]] ## [1] 43.65396 ## ## ## $coords[[3]] ## $coords[[3]][[1]] ## [1] 34.78053 ## ## $coords[[3]][[2]] ## [1] 32.08048 ## ## ## $coords[[4]] ## $coords[[4]][[1]] ## [1] 8.542322 ## ## $coords[[4]][[2]] ## [1] 47.3724 ## ## ## ## $country ## $country[[1]] ## [1] &quot;Germany&quot; ## ## $country[[2]] ## [1] &quot;Canada&quot; ## ## $country[[3]] ## [1] &quot;Israel&quot; ## ## $country[[4]] ## [1] &quot;Switzerland&quot; 6.4 Flattening Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) coordinates &lt;- komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) It can occur that we end up with lists which are unnecessarily deep and we would like to make them flatter to make it easier to handle them. We are starting in our setup with komoot_content and coordinates from section “Iterating and traversing”. An example for an list that seems a bit too deep is given here: coordinates %&gt;% pluck(1) ## [[1]] ## [1] 13.38886 ## ## [[2]] ## [1] 52.51704 We can chop off a layer of a list and end up with a vector with one of the functions purrr::flatten_*(). In the * we need to specify what class the output will be: coordinates %&gt;% pluck(1) %&gt;% flatten_dbl() ## [1] 13.38886 52.51704 Let’s use map() to apply this to the entire list of our cities’ coordinates: coordinates %&gt;% map(flatten_dbl) ## [[1]] ## [1] 13.38886 52.51704 ## ## [[2]] ## [1] -79.38721 43.65396 ## ## [[3]] ## [1] 34.78053 32.08048 ## ## [[4]] ## [1] 8.542322 47.372396 6.5 Transposing Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) coordinates &lt;- komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) You might know the mathematical concept of transposition from your linear algebra courses. A similar concept is available in R when we are dealing with lists. We are starting in our setup with komoot_content and coordinates from section “Iterating and traversing”. Let’s apply purrr::transpose() to our list coordinates: coordinates %&gt;% transpose() ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] -79.38721 ## ## [[1]][[3]] ## [1] 34.78053 ## ## [[1]][[4]] ## [1] 8.542322 ## ## ## [[2]] ## [[2]][[1]] ## [1] 52.51704 ## ## [[2]][[2]] ## [1] 43.65396 ## ## [[2]][[3]] ## [1] 32.08048 ## ## [[2]][[4]] ## [1] 47.3724 What was originally a list with 4 elements of which each one was a list of 2 elements has become a list of 2 elements of which each one is a list of 4 elements. With flatten_dbl() we can simplify the structure, so that we end up with a list of 2, where each element consists of a vector of 4. The first vector contains the longitude and the second the latitude of our cities: coordinates_transposed &lt;- coordinates %&gt;% transpose() %&gt;% map(~ flatten_dbl(.)) coordinates_transposed ## [[1]] ## [1] 13.388860 -79.387207 34.780527 8.542322 ## ## [[2]] ## [1] 52.51704 43.65396 32.08048 47.37240 6.5.1 Exercises Explain what happens if you transpose a tibble: komoot %&gt;% transpose() 6.6 Rectangling Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) coordinates_transposed &lt;- komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) %&gt;% transpose() %&gt;% map(~ flatten_dbl(.)) Most of us R-users feel most at ease when dealing in R with data frames on which we can use a plethora of well-known (by us) functions with non-startling behaviour. What if we don’t get our data in such a form? We are starting in our setup with the list coordinates_transposed from section “Transposing”. A tibble is internally a list of named vectors of equal length. In two easy steps we can therefore make a tibble out of the unnamed list coordinates_transposed: coordinates_transposed %&gt;% rlang::set_names(c(&quot;lon&quot;, &quot;lat&quot;)) ## $lon ## [1] 13.388860 -79.387207 34.780527 8.542322 ## ## $lat ## [1] 52.51704 43.65396 32.08048 47.37240 coordinates_transposed %&gt;% rlang::set_names(c(&quot;lon&quot;, &quot;lat&quot;)) %&gt;% as_tibble() ## # A tibble: 4 x 2 ## lon lat ## &lt;dbl&gt; &lt;dbl&gt; ## 1 13.4 52.5 ## 2 -79.4 43.7 ## 3 34.8 32.1 ## 4 8.54 47.4 If you want to keep the names open for now, but still get a tibble, you can set as_tibble()’s argument .name_repair = &quot;universal&quot;: coordinates_transposed %&gt;% as_tibble(.name_repair = &quot;universal&quot;) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## # A tibble: 4 x 2 ## ...1 ...2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 13.4 52.5 ## 2 -79.4 43.7 ## 3 34.8 32.1 ## 4 8.54 47.4 coordinates_transposed %&gt;% as_tibble(.name_repair = &quot;universal&quot;) %&gt;% rename(lon = ...1, lat = ...2) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## # A tibble: 4 x 2 ## lon lat ## &lt;dbl&gt; &lt;dbl&gt; ## 1 13.4 52.5 ## 2 -79.4 43.7 ## 3 34.8 32.1 ## 4 8.54 47.4 6.7 Accessing APIs Click here to show setup code. library(tidyverse) library(here) When dealing with web-APIs, query results come frequently in the JSON (JavaScript Object Notation) format. How to deal with this in R? A way to “talk” with APIs is provided by the package {httr}. The “GET”-query is executed by using httr::GET() with the URL, containing the query specifics, as an argument: req &lt;- httr::GET(&quot;https://photon.komoot.de/api/?q=Paradeplatz&amp;limit=3&quot;) If you are using this command in a script, you need to wait until the query is finished processing: httr::stop_for_status(req) The result of the query can be accessed via httr::content(): content &lt;- httr::content(req) content ## $features ## $features[[1]] ## $features[[1]]$geometry ## $features[[1]]$geometry$coordinates ## $features[[1]]$geometry$coordinates[[1]] ## [1] 8.538948 ## ## $features[[1]]$geometry$coordinates[[2]] ## [1] 47.36981 ## ## ## $features[[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[1]]$type ## [1] &quot;Feature&quot; ## ## $features[[1]]$properties ## $features[[1]]$properties$osm_id ## [1] 905841 ## ## $features[[1]]$properties$osm_type ## [1] &quot;R&quot; ## ## $features[[1]]$properties$extent ## $features[[1]]$properties$extent[[1]] ## [1] 8.538163 ## ## $features[[1]]$properties$extent[[2]] ## [1] 47.37027 ## ## $features[[1]]$properties$extent[[3]] ## [1] 8.539516 ## ## $features[[1]]$properties$extent[[4]] ## [1] 47.36935 ## ## ## $features[[1]]$properties$country ## [1] &quot;Switzerland&quot; ## ## $features[[1]]$properties$osm_key ## [1] &quot;highway&quot; ## ## $features[[1]]$properties$city ## [1] &quot;Zurich&quot; ## ## $features[[1]]$properties$osm_value ## [1] &quot;pedestrian&quot; ## ## $features[[1]]$properties$postcode ## [1] &quot;8001&quot; ## ## $features[[1]]$properties$name ## [1] &quot;Paradeplatz&quot; ## ## $features[[1]]$properties$state ## [1] &quot;Zurich&quot; ## ## ## ## $features[[2]] ## $features[[2]]$geometry ## $features[[2]]$geometry$coordinates ## $features[[2]]$geometry$coordinates[[1]] ## [1] 7.108249 ## ## $features[[2]]$geometry$coordinates[[2]] ## [1] 50.88602 ## ## ## $features[[2]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[2]]$type ## [1] &quot;Feature&quot; ## ## $features[[2]]$properties ## $features[[2]]$properties$osm_id ## [1] 389550464 ## ## $features[[2]]$properties$osm_type ## [1] &quot;N&quot; ## ## $features[[2]]$properties$country ## [1] &quot;Germany&quot; ## ## $features[[2]]$properties$osm_key ## [1] &quot;place&quot; ## ## $features[[2]]$properties$city ## [1] &quot;Cologne&quot; ## ## $features[[2]]$properties$osm_value ## [1] &quot;locality&quot; ## ## $features[[2]]$properties$postcode ## [1] &quot;51147&quot; ## ## $features[[2]]$properties$name ## [1] &quot;Paradeplatz&quot; ## ## $features[[2]]$properties$state ## [1] &quot;North Rhine-Westphalia&quot; ## ## ## ## $features[[3]] ## $features[[3]]$geometry ## $features[[3]]$geometry$coordinates ## $features[[3]]$geometry$coordinates[[1]] ## [1] 8.684258 ## ## $features[[3]]$geometry$coordinates[[2]] ## [1] 49.38674 ## ## ## $features[[3]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[3]]$type ## [1] &quot;Feature&quot; ## ## $features[[3]]$properties ## $features[[3]]$properties$osm_id ## [1] 391678888 ## ## $features[[3]]$properties$osm_type ## [1] &quot;W&quot; ## ## $features[[3]]$properties$extent ## $features[[3]]$properties$extent[[1]] ## [1] 8.683635 ## ## $features[[3]]$properties$extent[[2]] ## [1] 49.38719 ## ## $features[[3]]$properties$extent[[3]] ## [1] 8.68488 ## ## $features[[3]]$properties$extent[[4]] ## [1] 49.3863 ## ## ## $features[[3]]$properties$country ## [1] &quot;Germany&quot; ## ## $features[[3]]$properties$osm_key ## [1] &quot;place&quot; ## ## $features[[3]]$properties$city ## [1] &quot;Heidelberg&quot; ## ## $features[[3]]$properties$osm_value ## [1] &quot;locality&quot; ## ## $features[[3]]$properties$postcode ## [1] &quot;69120&quot; ## ## $features[[3]]$properties$name ## [1] &quot;Paradeplatz&quot; ## ## $features[[3]]$properties$state ## [1] &quot;Baden-Württemberg&quot; ## ## ## ## ## $type ## [1] &quot;FeatureCollection&quot; As you can see, the result, as it is displayed in R, is already a nested list at this point. And we know how to deal with these objects. The object did originally come as a JSON object though, which you can see if you look at the literal result of the query: text_content &lt;- httr::content(req, as = &quot;text&quot;) cat(text_content) ## {&quot;features&quot;:[{&quot;geometry&quot;:{&quot;coordinates&quot;:[8.538948327037028,47.369806999999994],&quot;type&quot;:&quot;Point&quot;},&quot;type&quot;:&quot;Feature&quot;,&quot;properties&quot;:{&quot;osm_id&quot;:905841,&quot;osm_type&quot;:&quot;R&quot;,&quot;extent&quot;:[8.5381631,47.3702704,8.5395156,47.3693475],&quot;country&quot;:&quot;Switzerland&quot;,&quot;osm_key&quot;:&quot;highway&quot;,&quot;city&quot;:&quot;Zurich&quot;,&quot;osm_value&quot;:&quot;pedestrian&quot;,&quot;postcode&quot;:&quot;8001&quot;,&quot;name&quot;:&quot;Paradeplatz&quot;,&quot;state&quot;:&quot;Zurich&quot;}},{&quot;geometry&quot;:{&quot;coordinates&quot;:[7.1082488,50.8860177],&quot;type&quot;:&quot;Point&quot;},&quot;type&quot;:&quot;Feature&quot;,&quot;properties&quot;:{&quot;osm_id&quot;:389550464,&quot;osm_type&quot;:&quot;N&quot;,&quot;country&quot;:&quot;Germany&quot;,&quot;osm_key&quot;:&quot;place&quot;,&quot;city&quot;:&quot;Cologne&quot;,&quot;osm_value&quot;:&quot;locality&quot;,&quot;postcode&quot;:&quot;51147&quot;,&quot;name&quot;:&quot;Paradeplatz&quot;,&quot;state&quot;:&quot;North Rhine-Westphalia&quot;}},{&quot;geometry&quot;:{&quot;coordinates&quot;:[8.684257597277371,49.3867415],&quot;type&quot;:&quot;Point&quot;},&quot;type&quot;:&quot;Feature&quot;,&quot;properties&quot;:{&quot;osm_id&quot;:391678888,&quot;osm_type&quot;:&quot;W&quot;,&quot;extent&quot;:[8.6836355,49.3871856,8.6848797,49.3862973],&quot;country&quot;:&quot;Germany&quot;,&quot;osm_key&quot;:&quot;place&quot;,&quot;city&quot;:&quot;Heidelberg&quot;,&quot;osm_value&quot;:&quot;locality&quot;,&quot;postcode&quot;:&quot;69120&quot;,&quot;name&quot;:&quot;Paradeplatz&quot;,&quot;state&quot;:&quot;Baden-Württemberg&quot;}}],&quot;type&quot;:&quot;FeatureCollection&quot;} The package {jsonlite} has the function jsonlite::prettify() to offer, in order to display a one-line JSON-structure in a more clearly laid-out manner: cat(jsonlite::prettify(text_content)) ## { ## &quot;features&quot;: [ ## { ## &quot;geometry&quot;: { ## &quot;coordinates&quot;: [ ## 8.538948327037028, ## 47.369806999999994 ## ], ## &quot;type&quot;: &quot;Point&quot; ## }, ## &quot;type&quot;: &quot;Feature&quot;, ## &quot;properties&quot;: { ## &quot;osm_id&quot;: 905841, ## &quot;osm_type&quot;: &quot;R&quot;, ## &quot;extent&quot;: [ ## 8.5381631, ## 47.3702704, ## 8.5395156, ## 47.3693475 ## ], ## &quot;country&quot;: &quot;Switzerland&quot;, ## &quot;osm_key&quot;: &quot;highway&quot;, ## &quot;city&quot;: &quot;Zurich&quot;, ## &quot;osm_value&quot;: &quot;pedestrian&quot;, ## &quot;postcode&quot;: &quot;8001&quot;, ## &quot;name&quot;: &quot;Paradeplatz&quot;, ## &quot;state&quot;: &quot;Zurich&quot; ## } ## }, ## { ## &quot;geometry&quot;: { ## &quot;coordinates&quot;: [ ## 7.1082488, ## 50.8860177 ## ], ## &quot;type&quot;: &quot;Point&quot; ## }, ## &quot;type&quot;: &quot;Feature&quot;, ## &quot;properties&quot;: { ## &quot;osm_id&quot;: 389550464, ## &quot;osm_type&quot;: &quot;N&quot;, ## &quot;country&quot;: &quot;Germany&quot;, ## &quot;osm_key&quot;: &quot;place&quot;, ## &quot;city&quot;: &quot;Cologne&quot;, ## &quot;osm_value&quot;: &quot;locality&quot;, ## &quot;postcode&quot;: &quot;51147&quot;, ## &quot;name&quot;: &quot;Paradeplatz&quot;, ## &quot;state&quot;: &quot;North Rhine-Westphalia&quot; ## } ## }, ## { ## &quot;geometry&quot;: { ## &quot;coordinates&quot;: [ ## 8.684257597277371, ## 49.3867415 ## ], ## &quot;type&quot;: &quot;Point&quot; ## }, ## &quot;type&quot;: &quot;Feature&quot;, ## &quot;properties&quot;: { ## &quot;osm_id&quot;: 391678888, ## &quot;osm_type&quot;: &quot;W&quot;, ## &quot;extent&quot;: [ ## 8.6836355, ## 49.3871856, ## 8.6848797, ## 49.3862973 ## ], ## &quot;country&quot;: &quot;Germany&quot;, ## &quot;osm_key&quot;: &quot;place&quot;, ## &quot;city&quot;: &quot;Heidelberg&quot;, ## &quot;osm_value&quot;: &quot;locality&quot;, ## &quot;postcode&quot;: &quot;69120&quot;, ## &quot;name&quot;: &quot;Paradeplatz&quot;, ## &quot;state&quot;: &quot;Baden-Württemberg&quot; ## } ## } ## ], ## &quot;type&quot;: &quot;FeatureCollection&quot; ## } "],
["tidy-evaluation.html", "7 Tidy evaluation 7.1 A custom plotting function 7.2 Do you need tidy evaluation? 7.3 Explicit quote-unquote of ellipsis 7.4 Names 7.5 Debugging 7.6 Argument names 7.7 purrr-style mappers", " 7 Tidy evaluation writing functions that work with datasets of different shape This chapter offers an introduction to tidy evaluation. Knowledge of tidy evaluation can become necessary when creating own functions in the framework of the tidyverse. The code in this chapter requires the rlang package, which provides the functions required for tidy evaluation, in addition to the tidyverse. library(tidyverse) library(rlang) 7.1 A custom plotting function Let’s try to build a function that takes a data frame and an unquoted column name and produces a histogram from this column. A naive approach would be the following function definition: tidy_histogram &lt;- function(.data, x) { .data %&gt;% ggplot(aes(x = x)) + geom_histogram() } Let’s test this function in an easy setting: data &lt;- tibble(a = 1:10) try(print( data %&gt;% tidy_histogram(a) )) ## Error in FUN(X[[i]], ...) : object &#39;a&#39; not found try(print( data %&gt;% tidy_histogram(&quot;a&quot;) )) ## Error : StatBin requires a continuous x variable: the x variable is discrete. Perhaps you want stat=&quot;count&quot;? Neither the first nor the second attempt worked. What went wrong? If we add another column called x, it suddenly works: data &lt;- tibble(a = 1:10, x = 11:20) data %&gt;% tidy_histogram(a) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. The reason for it is, that our function is hard-coded to display a variable called x. The problem lies in the code-snippet aes(x = x). In the tidyverse the solution for avoiding these ambiguities is by using expressions to capture the meaning (here: user input) of an unquoted variable and subsequently the bang-bang-operator (written in the code as !!; also called “unquote”) to access/pass on this meaning at the right place. In our example we do the following: tidy_histogram &lt;- function(.data, x) { # Treat the argument as a variable name expr &lt;- enquo(x) .data %&gt;% # Tell ggplot2 that expr *contains* the name of the variable, # instead of expecting a variable named `expr` ggplot(aes(x = !!expr)) + geom_histogram() } data %&gt;% tidy_histogram(a) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. data %&gt;% tidy_histogram(x) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. try(print( data %&gt;% tidy_histogram(y) )) ## Error in FUN(X[[i]], ...) : object &#39;y&#39; not found But this behavior is different from our usual base-R usage of variables in functions. How do some functions behave this way and others another way? Let’s have a look at how the ‘problematic’ tidyverse function aes() is implemented: aes ## function (x, y, ...) ## { ## exprs &lt;- rlang::enquos(x = x, y = y, ...) ## is_missing &lt;- vapply(exprs, rlang::quo_is_missing, logical(1)) ## aes &lt;- new_aes(exprs[!is_missing], env = parent.frame()) ## rename_aes(aes) ## } ## &lt;bytecode: 0x4d808c0&gt; ## &lt;environment: namespace:ggplot2&gt; The reason for the behavior seen above is that the function itself makes use of capturing user input as an expression. In this case it uses the function enquos(), which captures one or more expressions along with an unique identifier for the environment in which they are supposed to be evaluated eventually. The default is to evaluate an expression (“standard evaluation”). With enquo() and enquos() the expressions that correspond to user input are captured. As an example of a newly-built function in the tidyverse, here is a function that combines the functionalities of dplyr::mutate() and purrr::map_dbl(). It takes as arguments a data frame, the column it is supposed to act upon and the function call it is supposed to use on each of the columns values: mutate_map_dbl &lt;- function(.data, col, expr) { quo &lt;- enquo(col) .data %&gt;% mutate(new_column = map_dbl(!!quo, expr)) } iris_nested &lt;- iris %&gt;% nest(-Species) iris_nested %&gt;% mutate_map_dbl(data, ~ mean(.$Petal.Width)) ## # A tibble: 3 x 3 ## Species data new_column ## &lt;fct&gt; &lt;list&gt; &lt;dbl&gt; ## 1 setosa &lt;tibble [50 × 4]&gt; 0.246 ## 2 versicolor &lt;tibble [50 × 4]&gt; 1.33 ## 3 virginica &lt;tibble [50 × 4]&gt; 2.03 7.2 Do you need tidy evaluation? Click here to show setup code. library(tidyverse) So does everyone who wants to create any functions in the framework of the tidyverse need deep knowledge about tidy evaluation? The answer is, it depends: often enough, things “just work”. In the following example, which is a slight extension of dplyr::summarize(), you do not need to capture any expressions. The function takes a data frame and an ellipsis. And the ellipsis can be directly passed on to a tidyverse function (buzzphrase: “pass the dots”). summarize_ungroup &lt;- function(.data, ...) { .data %&gt;% summarize(...) %&gt;% ungroup() } The function does what it promised to do: mean_airtime_per_day &lt;- nycflights13::flights %&gt;% group_by(year, month, day) %&gt;% summarize_ungroup(mean(air_time, na.rm = TRUE)) mean_airtime_per_day ## # A tibble: 365 x 4 ## year month day `mean(air_time, na.rm = TRUE)` ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 170. ## 2 2013 1 2 162. ## 3 2013 1 3 157. ## # … with 362 more rows mean_airtime_per_day %&gt;% groups() ## NULL 7.3 Explicit quote-unquote of ellipsis Click here to show setup code. library(tidyverse) library(rlang) There are cases though, when you need knowledge about what the user added to the ellipsis. This is then handled by capturing the content in a list of quosures, which can be unquoted by the !!!-operator. You need the “triple-bang” operator here, because the ellipsis can hold more than one expression. !!! does two things: it unquotes the content and splices it into the current call. We can practice this with our little new tidyverse function summarize_ungroup(): summarize_ungroup &lt;- function(.data, ...) { # Capture (quote) with enquos() quos &lt;- enquos(...) # Use (unquote-splice) with !!! .data %&gt;% summarize(!!!quos) %&gt;% ungroup() } We didn’t need to process the content, but it still works, as we can see here: mean_airtime_per_day &lt;- nycflights13::flights %&gt;% group_by(year, month, day) %&gt;% summarize_ungroup(mean(air_time, na.rm = TRUE)) mean_airtime_per_day ## # A tibble: 365 x 4 ## year month day `mean(air_time, na.rm = TRUE)` ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 170. ## 2 2013 1 2 162. ## 3 2013 1 3 157. ## # … with 362 more rows mean_airtime_per_day %&gt;% groups() ## NULL To come back to our original example: aes() uses exactly this “quote-unquote-splice”-pattern: aes ## function (x, y, ...) ## { ## exprs &lt;- rlang::enquos(x = x, y = y, ...) ## is_missing &lt;- vapply(exprs, rlang::quo_is_missing, logical(1)) ## aes &lt;- new_aes(exprs[!is_missing], env = parent.frame()) ## rename_aes(aes) ## } ## &lt;bytecode: 0x4d808c0&gt; ## &lt;environment: namespace:ggplot2&gt; At the time of producing the material for this course, summarize() did not make use of this pattern. 7.4 Names Click here to show setup code. library(tidyverse) library(rlang) User input in an ellipsis can be named or unnamed. We can distinguish between those two kinds and make use of this distinction, in the following way creating a special interface for the function: gsu &lt;- function(.data, ...) { # Capture (quote) with enquos() quos &lt;- enquos(...) is_named &lt;- (names2(quos) != &quot;&quot;) named_quos &lt;- quos[is_named] unnamed_quos &lt;- quos[!is_named] # Use (unquote-splice) with !!! .data %&gt;% group_by(!!!unnamed_quos) %&gt;% summarize(!!!named_quos) %&gt;% ungroup() } The named_quos are our summary columns (name is name of the new column, value is the expression to be used on the input column(s)) and the unnamed_quos are now the grouping columns: mean_airtime_per_day &lt;- nycflights13::flights %&gt;% gsu(year, month, day, mean_air_time = mean(air_time, na.rm = TRUE)) mean_airtime_per_day ## # A tibble: 365 x 4 ## year month day mean_air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 170. ## 2 2013 1 2 162. ## 3 2013 1 3 157. ## # … with 362 more rows 7.5 Debugging Click here to show setup code. library(rlang) You can use the capturing functions (creating quosures or expressions) also outside of functions: quos(x = a) ## $x ## &lt;quosure&gt; ## expr: ^a ## env: 0x36a96e8 a &lt;- sym(&quot;b&quot;) x_quos &lt;- quos(x = !!a) x_quos ## $x ## &lt;quosure&gt; ## expr: ^b ## env: 0x36a96e8 The sym() function here creates a so-called symbol from a character variable. Unquoting a symbol variable means that the symbol is interpreted as a variable in the dataset. Capturing expressions in quosures can help you understand what is happening behind the scenes and for example give you clues as to why your code is not doing what it is supposed to do. Quosures can also be nested: quos(y = c, !!!x_quos) ## $y ## &lt;quosure&gt; ## expr: ^c ## env: 0x36a96e8 ## ## $x ## &lt;quosure&gt; ## expr: ^b ## env: 0x36a96e8 7.6 Argument names Click here to show setup code. library(tidyverse) library(rlang) At the end of section A custom plotting function we defined a function mutate_map_dbl(). A downside of this function was, that it did create the desired new column, but you weren’t able to specify the column name in the function call. Let’s try to improve this aspect of the function: mutate_map_dbl &lt;- function(.data, col, ...) { quos &lt;- build_quos(!!enquo(col), ...) .data %&gt;% mutate(!!!quos) } build_quos &lt;- function(col, ...) { args &lt;- list(...) stopifnot(length(args) == 1) expr &lt;- args[[1]] map_quo &lt;- build_map_quo(!!enquo(col), expr) set_names(list(map_quo), names(args)) } build_map_quo &lt;- function(col, expr) { quo &lt;- enquo(col) quo(map_dbl(!!quo, expr)) } Again, like in section Names we are able to make use of the fact that an expression in an ellipsis of sorts x = y is treated in a way, that x is the name and y is the value of an object (here we used this in the code snippet names(args)). A lot of things happen here: 1. the main function mutate_map_dbl() calls a helper function build_quos() 2. build_quos() in turn calls a helper’s helper function build_map_quo() 3. mutate_map_dbl() then uses the output of the nested function calls to (hopefully) produce the desired result. What output do the two helper functions produce? Let’s test it: build_quos(data, mean_petal_width = ~ mean(.$Petal.Width)) ## $mean_petal_width ## &lt;quosure&gt; ## expr: ^map_dbl(^data, expr) ## env: 0x9122938 build_map_quo(mean_petal_width, ~ mean(.$Petal.Width)) ## &lt;quosure&gt; ## expr: ^map_dbl(^mean_petal_width, expr) ## env: 0xb4dfc30 And finally, let’s see if our function lives up to our expectations: iris %&gt;% nest(-Species) %&gt;% mutate_map_dbl(data, mean_petal_width = ~ mean(.$Petal.Width)) ## # A tibble: 3 x 3 ## Species data mean_petal_width ## &lt;fct&gt; &lt;list&gt; &lt;dbl&gt; ## 1 setosa &lt;tibble [50 × 4]&gt; 0.246 ## 2 versicolor &lt;tibble [50 × 4]&gt; 1.33 ## 3 virginica &lt;tibble [50 × 4]&gt; 2.03 7.7 purrr-style mappers Click here to show setup code. library(tidyverse) library(rlang) mutate_map_dbl &lt;- function(.data, col, ...) { quos &lt;- build_quos(!!enquo(col), ...) .data %&gt;% mutate(!!!quos) } Is there still potential to improve our function mutate_map_dbl()? We start here with only the highest level function definition of mutate_map_dbl() from section Argument names, i.e. without the definition of its helper functions build_quos() and build_map_quo(). What we are trying to achieve now, is to rid ourselves from the need to provide the tilde before the function. This is a slightly more tricky task, and here is how to go about it: build_quos &lt;- function(col, ...) { args &lt;- enquos(...) stopifnot(length(args) == 1) expr &lt;- args[[1]] map_quo &lt;- build_map_quo(!!enquo(col), !!expr) set_names(list(map_quo), names(args)) } build_map_quo &lt;- function(col, expr) { quo &lt;- enquo(col) mapper &lt;- as_mapper_quosure(!!enquo(expr)) quo(map_dbl(!!quo, !!mapper)) } as_mapper_quosure &lt;- function(expr) { quo &lt;- enquo(expr) rlang::new_function( alist(... = , . = ..1, .x = ..1, .y = ..2), quo_get_expr(quo), quo_get_env(quo) ) } We needed to add one more level in the hierarchy of function calling. The helper function as_mapper_quosure() creates a new function with the help of rlang::new_function(), which eventually makes it possible to leave out the tilde. as_mapper(~ mean(.$Petal.Width)) ## &lt;lambda&gt; ## function (..., .x = ..1, .y = ..2, . = ..1) ## mean(.$Petal.Width) ## &lt;environment: 0x36a96e8&gt; ## attr(,&quot;class&quot;) ## [1] &quot;rlang_lambda_function&quot; as_mapper_quosure(mean(.$Petal.Width)) ## function (..., . = ..1, .x = ..1, .y = ..2) ## mean(.$Petal.Width) ## &lt;environment: 0x36a96e8&gt; build_map_quo(mean_petal_width, mean(.$Petal.Width)) ## &lt;quosure&gt; ## expr: ^map_dbl(^mean_petal_width, &lt;function(..., . = ..1, .x = ..1, ## .y = ..2) mean(.$Petal.Width)&gt;) ## env: 0x9a675a0 We see that our function as_mapper_quosure() is closely related to the function purrr::as_mapper(), but produces a quosure of a proper function and not a lambda function. Also, it does not require the tilde. So much to the theory, but does our main function also still behave in the right way? iris %&gt;% nest(-Species) %&gt;% mutate_map_dbl(data, mean_petal_width = mean(.$Petal.Width)) ## # A tibble: 3 x 3 ## Species data mean_petal_width ## &lt;fct&gt; &lt;list&gt; &lt;dbl&gt; ## 1 setosa &lt;tibble [50 × 4]&gt; 0.246 ## 2 versicolor &lt;tibble [50 × 4]&gt; 1.33 ## 3 virginica &lt;tibble [50 × 4]&gt; 2.03 "],
["best-practices.html", "8 Best practices 8.1 DESCRIPTION 8.2 R 8.3 roxygen2 8.4 testthat", " 8 Best practices R code is often organized in packages that can be installed from centralized repositories such as CRAN or GitHub. If you are new to writing R packages, this course cannot give a complete introduction into packages. It is still useful to embrace some very few concepts of R packages to gain access to a vast toolbox and also organize your code in a standardized way familiar to other users. With the first steps in place, the road to your first R package may become less steep. Create a DESCRIPTION file to declare dependencies and allow easy reloading of the functions you define Store your functions in .R files in the R/ directory in your project Scripts that you execute live in script/ or a similar directory Use roxygen2 to document your functions close to the source Write tests for your functions, e.g. with testthat See R packages for a more comprehensive treatment. 8.1 DESCRIPTION Create and open a new RStudio project. Then, create a DESCRIPTION file with usethis::use_description(): # install.packages(&quot;usethis&quot;) usethis::use_description() Double-check success: # install.packages(&quot;devtools&quot;) devtools::load_all() Declare that your project requires the tidyverse and the here package: usethis::use_package(&quot;here&quot;) # Currently doesn&#39;t work, add manually # https://github.com/r-lib/usethis/issues/760 # usethis::use_package(&quot;tidyverse&quot;) 8.2 R With a DESCRIPTION file defined, create a new .R file and save it in the R/ directory. (Create this directory if it does not exist.) Create a function in this file, save the file: hi &lt;- function(text = &quot;Hello, world!&quot;) { print(text) invisible(text) } Do not source the file. Restart R (with Ctrl + Shift + F10 in RStudio). Run devtools::load_all() again, you can use the shortcut Ctrl + Shift + L or Cmd + Shift + L in RStudio. Check that you can run hi() in the console: hi() ## [1] &quot;Hello, world!&quot; hi(&quot;Wow!&quot;) ## [1] &quot;Wow!&quot; Edit the function: hi &lt;- function(text = &quot;Wow!&quot;) { print(text) invisible(text) } Save the file, but do not source it. Run devtools::load_all() again, you can use the shortcut Ctrl + Shift + L or Cmd + Shift + L in RStudio. Check that the new implementation of hi() is active: hi() ## [1] &quot;Wow!&quot; All functions that are required for your project are stored in this directory. Do not store executable scripts, use a script/ directory. 8.3 roxygen2 The following intuitive annotation syntax is a standard way to create documentation for your functions: #&#39; Print a welcome message #&#39; #&#39; This function prints &quot;Wow!&quot;, or a custom text, on the console. #&#39; #&#39; @param text The text to print, &quot;Wow!&quot; by default. #&#39; #&#39; @return The `text` argument, invisibly. #&#39; #&#39; @examples #&#39; hi() #&#39; hi(&quot;Hello!&quot;) hi &lt;- function(text = &quot;Wow!&quot;) { print(text) invisible(text) } This annotation can be rendered to a nicely looking HTML page with the roxygen2 and pkgdown packages. All you need to do is provide (and maintain) it. 8.4 testthat Automated tests make sure that the functions you write today continue working tomorrow. Create your first test with usethis::use_test(): # install.packages(&quot;testthat&quot;) usethis::use_test(&quot;hi&quot;) The file tests/testthat/test-hi.R is created, with the following contents: test_that(&quot;multiplication works&quot;, { expect_equal(2 * 2, 4) }) Replace this predefined text with a test that makes more sense for us: test_that(&quot;hi() works&quot;, { expect_output(hi(), &quot;Wow&quot;) expect_output(hi(&quot;Hello&quot;), &quot;Hello&quot;) }) Run the new test with devtools::test(), you can use the shortcut Ctrl + Shift + T or Cmd + Shift + T in RStudio. Check that the test actually detects failures by modifying the implementation of hi() and rerunning the test: hi &lt;- function(text = &quot;Oops!&quot;) { print(text) invisible(text) } Run the new test with devtools::test(), you can use the shortcut Ctrl + Shift + T or Cmd + Shift + T in RStudio. One test should be failing now. "],
["references.html", "# References", " # References R for data science: https://r4ds.had.co.nz/ Row oriented workflows: https://github.com/jennybc/row-oriented-workflows#readme Advanced R: http://adv-r.had.co.nz/ Tidy evaluation: https://tidyeval.tidyverse.org/ R packages: http://r-pkgs.had.co.nz/ roxygen2: Vignettes in https://cran.r-project.org/package=roxygen2, especially: Introduction to roxygen2 Generating Rd files for an overview of available tags Write R documentation in Markdown How R searches and finds stuff: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/ What they forgot to teach you: https://whattheyforgot.org/ Parallel processing with a purrr-like interface: https://davisvaughan.github.io/furrr/ Tidyverse principles: https://principles.tidyverse.org/ Recursive lists to use in teaching and examples: https://github.com/jennybc/repurrrsive "]
]
