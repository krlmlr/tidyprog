[
["index.html", "Programming in the tidyverse Preface", " Programming in the tidyverse Kirill M√ºller, Tobias Schieferdecker 09 May 2019, 21:16 CEST Preface "],
["introduction.html", "1 Introduction", " 1 Introduction The tidyverse has quickly developed over the last years. Its first implementation as a collection of partly older packages was in the second half of 2016. All its packages ‚Äúshare an underlying design philosophy, grammar, and data structures.‚Äù1 It is for sure difficult to tell, if ‚Äúlearning the tidyverse‚Äù is a hard task, since the result of this assessment might differ from person to person. We do believe though, that there are concepts in its approach, which ‚Äì when grasped ‚Äì have the potential to increase one‚Äôs productivity, since code creation will seem more natural. While this might be true for all languages (once you speak it well enough, things go smoothly), in our opinion the tidyverse worth exploring in depth, since it is 1. an especially thought through framework that aims at making programming intuitive 2. evolving: challenges in the quickly changing world of hardware and software technology are addressed by tidyverse developers on comparably short notice This course covers several topics, which everyone working more intently with the tidyverse almost inevitably needs to deal with at some point or another. The first part, ‚ÄúSimple iteration‚Äù: We start off with an overview of basic issues, like data visualization and data exploration using packages ggplot2 and dplyr Then we look at how to get from a list or a vector to a tibble and vice-versa Next topic is indexing for vectors and lists Applying a function to each element of a list or a vector The second part, ‚ÄúFunction basics‚Äù: We begin with how to define and execute a function A functions arguments (from a developer‚Äôs and from a user‚Äôs perspective) The third part, ‚ÄúPairwise iteration and nesting‚Äù: Simultaneously feed 2 separate lists of inputs into a function working with those two arguments Iterate through column entries of a tibble Nested tibbles The fourth part, ‚ÄúScoping and flow control‚Äù: citation from tidyverse homepage‚Ü© "],
["simple-iteration.html", "2 Simple iteration 2.1 Review of visualization and data transformation 2.2 Vectors and columns 2.3 Named vectors and two-column tibbles 2.4 Indexing/subsetting 2.5 Construction 2.6 Processing multiple files 2.7 Manipulating all datasets 2.8 Typed output", " 2 Simple iteration Processing multiple files that contain different parts of the same dataset 2.1 Review of visualization and data transformation Click here to show setup code. library(tidyverse) ## ‚îÄ‚îÄ [1mAttaching packages[22m ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.2.1 ‚îÄ‚îÄ ## [32m‚úî[39m [34mggplot2[39m 3.1.1 [32m‚úî[39m [34mpurrr [39m 0.3.2 ## [32m‚úî[39m [34mtibble [39m 2.1.1 [32m‚úî[39m [34mdplyr [39m 0.8.0.[31m1[39m ## [32m‚úî[39m [34mtidyr [39m 0.8.3 [32m‚úî[39m [34mstringr[39m 1.4.0 ## [32m‚úî[39m [34mreadr [39m 1.3.1 [32m‚úî[39m [34mforcats[39m 0.4.0 ## ‚îÄ‚îÄ [1mConflicts[22m ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ ## [31m‚úñ[39m [34mdplyr[39m::[32mfilter()[39m masks [34mstats[39m::filter() ## [31m‚úñ[39m [34mdplyr[39m::[32mlag()[39m masks [34mstats[39m::lag() library(here) 2.1.1 Data We will be working with hourly measurements of weather data (link to data documentation) in four cities (Berlin, Toronto, Tel Aviv and Zurich) between 2019-04-28, 3pm and 2019-04-30, 3pm. Thus we have 49 observations in each city. Variables are: time summary (how to describe the weather in one word) icon (mix of description of weather plus time of day) precipIntensity (intensity of precipitation [mm/h]) precipProbability temperature apparentTemperature dewPoint humidity pressure windSpeed windGust windBearing (direction in degrees) cloudCover uvIndex visibility ozone precipType Reading in the data, which is stored in MS Excel-Files: berlin &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;berlin.xlsx&quot;)) toronto &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;toronto.xlsx&quot;)) tel_aviv &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;tel_aviv.xlsx&quot;)) zurich &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;zurich.xlsx&quot;)) Create one larger tibble from the four smaller ones: weather_data &lt;- bind_rows( berlin = berlin, toronto = toronto, tel_aviv = tel_aviv, zurich = zurich, .id = &quot;city_code&quot; ) 2.1.2 Exploration weather_data ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; Example plot of humidity vs.¬†pressure (geom_path() ensures that points are connected according to their order in the tibble): weather_data %&gt;% ggplot(aes(x = pressure, y = humidity, color = city_code)) + geom_path() Barplots of number of occurences of each kind of weather per city: weather_data %&gt;% ggplot(aes(x = city_code)) + geom_bar(aes(fill = summary)) weather_data %&gt;% ggplot(aes(x = city_code)) + geom_bar(aes(fill = summary), position = position_dodge2(&quot;dodge&quot;, preserve = &quot;single&quot;)) Lineplot with different line types and an additional visualisation of the line range (here, difference between apparent and actual temperature): temperature_data &lt;- weather_data %&gt;% select(city_code, time, temperature, apparentTemperature) %&gt;% gather(kind, temperature, -city_code, -time) %&gt;% mutate(apparent = (kind == &quot;apparentTemperature&quot;)) %&gt;% select(-kind) temperature_data %&gt;% ggplot(aes(x = time, color = city_code)) + geom_linerange(data = weather_data, aes(ymin = temperature, ymax = apparentTemperature)) + geom_line(aes(linetype = apparent, y = temperature)) Relation of temperature difference between actual and apparent temperature (cf.¬†line range in last plot) with wind speed, shown as scatter plot. weather_data %&gt;% mutate(apparentTemperatureReduction = temperature - apparentTemperature) %&gt;% filter(city_code != &quot;tel_aviv&quot;) %&gt;% ggplot(aes(x = windSpeed, y = apparentTemperatureReduction)) + geom_point(aes(color = city_code)) 2.1.3 Further possibilities of using {dplyr} to transform data If you want to compare measurements of the same observable at two different points in time, maybe the most straightforward way to do so is to create a new column with an appropriate lag: weather_data %&gt;% group_by(city_code) %&gt;% mutate_at(vars(temperature, pressure, humidity), list(lag = lag)) %&gt;% ungroup() ## # A tibble: 196 x 22 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 17 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt;, temperature_lag &lt;dbl&gt;, ## # pressure_lag &lt;dbl&gt;, humidity_lag &lt;dbl&gt; Count observations per category or combinations of categories: weather_data %&gt;% count(city_code) ## # A tibble: 4 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 toronto 49 ## 4 zurich 49 weather_data %&gt;% count(city_code, summary) ## # A tibble: 15 x 3 ## city_code summary n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 berlin Clear 17 ## 2 berlin Mostly Cloudy 11 ## 3 berlin Overcast 18 ## # ‚Ä¶ with 12 more rows Use summarize() to create a tibble with mean and maximum temperature for each city: weather_data %&gt;% group_by(city_code) %&gt;% summarize(temperature_mean = mean(temperature), temperature_max = max(temperature)) %&gt;% ungroup() ## # A tibble: 4 x 3 ## city_code temperature_mean temperature_max ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 berlin 12.5 20.0 ## 2 tel_aviv 22.6 28.8 ## 3 toronto 6.39 9.99 ## 4 zurich 7.15 14.3 Compute and display summary data for all numeric variables: weather_data %&gt;% group_by(city_code) %&gt;% summarize_if(is.numeric, list(mean = mean, sd = sd, min = min, max = max)) %&gt;% ungroup() %&gt;% gather(key, value, -city_code) %&gt;% separate(key, into = c(&quot;indicator&quot;, &quot;fun&quot;)) %&gt;% xtabs(value ~ city_code + indicator + fun, .) %&gt;% ftable() ## fun max mean min sd ## city_code indicator ## berlin apparentTemperature 19.98000000 11.62836735 3.45000000 5.07360997 ## cloudCover 1.00000000 0.59734694 0.00000000 0.42339292 ## dewPoint 10.18000000 5.23632653 1.88000000 2.45837742 ## humidity 0.88000000 0.63448980 0.35000000 0.15571156 ## ozone 378.04000000 343.34571429 319.68000000 21.60874350 ## precipIntensity 0.34800000 0.03084286 0.00000000 0.07902264 ## precipProbability 0.54000000 0.06000000 0.00000000 0.13913423 ## pressure 1020.48000000 1018.71714286 1016.10000000 1.19202733 ## temperature 19.98000000 12.49795918 6.14000000 4.10004115 ## uvIndex 5.00000000 1.24489796 0.00000000 1.61413821 ## visibility 16.09000000 15.77102041 10.01000000 1.13380672 ## windBearing 358.00000000 151.59183673 4.00000000 152.79205891 ## windGust 11.14000000 7.59591837 3.67000000 2.18713275 ## windSpeed 5.89000000 4.49326531 3.51000000 0.81341458 ## tel_aviv apparentTemperature 28.77000000 22.64591837 17.15000000 3.15235885 ## cloudCover 0.81000000 0.19693878 0.00000000 0.24908335 ## dewPoint 14.43000000 12.18244898 9.51000000 1.29219376 ## humidity 0.74000000 0.52612245 0.34000000 0.09347050 ## ozone 339.37000000 318.31836735 307.16000000 10.05895835 ## precipIntensity 0.00000000 0.00000000 0.00000000 0.00000000 ## precipProbability 0.00000000 0.00000000 0.00000000 0.00000000 ## pressure 1015.88000000 1013.66265306 1011.73000000 1.12583076 ## temperature 28.77000000 22.64591837 17.15000000 3.15235885 ## uvIndex 10.00000000 2.40816327 0.00000000 3.56439784 ## visibility 16.09000000 15.87163265 10.01000000 1.07987528 ## windBearing 355.00000000 188.36734694 0.00000000 123.84965581 ## windGust 5.53000000 3.47775510 1.66000000 1.19411101 ## windSpeed 4.90000000 2.49285714 0.57000000 1.04899754 ## toronto apparentTemperature 7.88000000 3.27306122 0.49000000 2.24842464 ## cloudCover 1.00000000 0.59510204 0.00000000 0.43183293 ## dewPoint 3.05000000 -1.26653061 -5.17000000 2.69193359 ## humidity 0.82000000 0.59734694 0.37000000 0.14628419 ## ozone 401.89000000 362.02632653 327.57000000 23.42483179 ## precipIntensity 0.84070000 0.08387551 0.00000000 0.16627247 ## precipProbability 0.51000000 0.06653061 0.00000000 0.11739447 ## pressure 1030.07000000 1025.14918367 1019.55000000 3.22083053 ## temperature 9.99000000 6.38795918 3.03000000 2.02387621 ## uvIndex 6.00000000 1.40816327 0.00000000 1.84750245 ## visibility 16.09000000 15.14673469 5.13000000 2.83815256 ## windBearing 357.00000000 140.32653061 2.00000000 129.30831820 ## windGust 11.51000000 7.51020408 2.66000000 2.33711939 ## windSpeed 7.64000000 4.87510204 1.91000000 1.62389080 ## zurich apparentTemperature 14.30000000 6.88551020 2.01000000 3.14469133 ## cloudCover 1.00000000 0.80877551 0.37000000 0.15734295 ## dewPoint 7.23000000 3.38367347 -0.27000000 1.90397030 ## humidity 0.88000000 0.77551020 0.59000000 0.08304269 ## ozone 377.57000000 359.81510204 340.69000000 11.33226737 ## precipIntensity 0.26670000 0.07106939 0.00000000 0.05976032 ## precipProbability 0.29000000 0.13326531 0.00000000 0.07816616 ## pressure 1023.55000000 1021.37612245 1017.40000000 1.62120174 ## temperature 14.30000000 7.14510204 2.01000000 3.07049475 ## uvIndex 4.00000000 1.10204082 0.00000000 1.44690615 ## visibility 16.09000000 12.90938776 3.89000000 4.47872769 ## windBearing 357.00000000 147.61224490 20.00000000 102.66182679 ## windGust 4.76000000 1.98428571 1.07000000 0.95327506 ## windSpeed 4.76000000 1.31244898 0.13000000 0.91823774 2.2 Vectors and columns Click here to show setup code. library(tidyverse) library(here) Here we briefly show the relationship between columns of data frames and their corresponding vectors, i.e.¬†the answer to ‚Äúhow to get from one to the other?‚Äù: We can e.g.¬†get a vector with the files in a specific directory of our current project2 like this: files &lt;- dir(here(&quot;data/weather&quot;), full.names = TRUE) files ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; You can create a tibble from it using tibble::enframe(): files_df &lt;- files %&gt;% enframe() files_df ## # A tibble: 4 x 2 ## name value ## &lt;int&gt; &lt;chr&gt; ## 1 1 /home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx ## 2 2 /home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx ## 3 3 /home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx ## 4 4 /home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx The name column might be unwanted in some cases. Suppress its creation by setting name = NULL: files_df_1 &lt;- files %&gt;% enframe(name = NULL) files_df_1 ## # A tibble: 4 x 1 ## value ## &lt;chr&gt; ## 1 /home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx ## 2 /home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx ## 3 /home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx ## 4 /home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx Another way to create a tibble from a vector is using tibble::tibble(). You can name the newly created columns by assigning the vectors they are created from to (quoted or unquoted) column names: tibble(filename = files) ## # A tibble: 4 x 1 ## filename ## &lt;chr&gt; ## 1 /home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx ## 2 /home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx ## 3 /home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx ## 4 /home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx The other direction ‚Äì producing a vector from a tibble column ‚Äì works with dplyr::pull(). By default pull() will turn the rightmost column into a vector and ignore the rest of the tibble: files_df %&gt;% pull() ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; Turn a specific column into a vector by providing the desired column name to pull(), either quoted or unquoted: files_df %&gt;% pull(name) ## [1] 1 2 3 4 2.2.1 Exercises Investigate the output of fs::dir_ls() with enframe(). Explain. # install.packages(&quot;fs&quot;) fs::dir_ls() fs::dir_ls() %&gt;% ___() ## # A tibble: 36 x 2 ## name value ## &lt;chr&gt; &lt;fs::path&gt; ## 1 2.Rmd 2.Rmd ## 2 21-intro.Rmd 21-intro.Rmd ## 3 22-dir.Rmd 22-dir.Rmd ## # ‚Ä¶ with 33 more rows 2.3 Named vectors and two-column tibbles Click here to show setup code. library(tidyverse) library(here) Here we look at tidyverse-functions to work with named vectors and tibbles with more columns and the relations netween the two. As seen in section ‚ÄúData‚Äù, load a table ‚Äì here a dictionary detailing information related to an id-like name ‚Äì from an MS Excel file with readxl::read_excel(): dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) dict ## # A tibble: 4 x 5 ## city_code weather_filename name lng lat ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 berlin data/weather/berlin.xlsx Berlin 13.4 52.5 ## 2 toronto data/weather/toronto.xlsx Toronto -79.4 43.7 ## 3 tel_aviv data/weather/tel_aviv.xlsx Tel Aviv 34.8 32.1 ## 4 zurich data/weather/zurich.xlsx Z√ºrich 8.54 47.4 Use pull() as seen in the last chapter: dict %&gt;% pull(weather_filename) ## [1] &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; ## [3] &quot;data/weather/tel_aviv.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; Create absolute paths using here::here(): dict %&gt;% pull(weather_filename) %&gt;% here() ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; Produce a named vector with tibble::deframe(), which is thought as the inverse function to enframe(). When given a 2-column tibble, deframe() will by default use the first column for the names and the second column for the values of the resulting vector. When given a 1-column tibble, it creates an unnamed vector. When given a more-than-2-column tibble, it will use the first two columns as name- and value-columns for the resulting vector, ignore the rest and in addition give a warning that it expects a one- or two-column data frame. weather_filenames &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() weather_filenames ## berlin toronto ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; ## tel_aviv zurich ## &quot;data/weather/tel_aviv.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; The names() function accesses the names of a vector: weather_filenames %&gt;% names() ## [1] &quot;berlin&quot; &quot;toronto&quot; &quot;tel_aviv&quot; &quot;zurich&quot; Some operations producing vectors from vectors cause the names to be lost: weather_filenames %&gt;% here() ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## [4] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; A possible solution can be in many cases to change the order of the transformations, so that the creation of the named vector comes last (or at least later): dict %&gt;% mutate(weather_filename_here = here(weather_filename)) %&gt;% select(city_code, weather_filename_here) %&gt;% deframe() ## berlin ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; ## toronto ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/toronto.xlsx&quot; ## tel_aviv ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/tel_aviv.xlsx&quot; ## zurich ## &quot;/home/travis/build/krlmlr/tidyprog/data/weather/zurich.xlsx&quot; 2.3.1 Exercises Obtain a mapping between city code and city name as a named vector. dict %&gt;% select(___, ___) %&gt;% deframe() ## berlin toronto tel_aviv zurich ## &quot;Berlin&quot; &quot;Toronto&quot; &quot;Tel Aviv&quot; &quot;Z√ºrich&quot; Convert the output of fs::dir_info() to that seen from fs::dir_ls(). How do you make sure that the vector is named? # install.packages(&quot;fs&quot;) fs::dir_info() fs::dir_info() %&gt;% pull(___) fs::dir_info() %&gt;% select(_____, _____) %&gt;% ___() ## # A tibble: 36 x 18 ## path type size permissions modification_time user group ## &lt;fs::path&gt; &lt;fct&gt; &lt;fs::b&gt; &lt;fs::perms&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2.Rmd file 462 rw-rw-r-- 2019-05-09 19:15:56 trav‚Ä¶ trav‚Ä¶ ## 2 21-intro.‚Ä¶ file 5.24K rw-rw-r-- 2019-05-09 19:15:56 trav‚Ä¶ trav‚Ä¶ ## 3 22-dir.Rmd file 2.41K rw-rw-r-- 2019-05-09 19:15:56 trav‚Ä¶ trav‚Ä¶ ## # ‚Ä¶ with 33 more rows, and 11 more variables: device_id &lt;dbl&gt;, ## # hard_links &lt;dbl&gt;, special_device_id &lt;dbl&gt;, inode &lt;dbl&gt;, ## # block_size &lt;dbl&gt;, blocks &lt;dbl&gt;, flags &lt;int&gt;, generation &lt;dbl&gt;, ## # access_time &lt;dttm&gt;, change_time &lt;dttm&gt;, birth_time &lt;dttm&gt; ## 2.Rmd 21-intro.Rmd 22-dir.Rmd ## 23-names.Rmd 24-index.Rmd 25-construct.Rmd ## 26-map.Rmd 27-map-manip.Rmd 28-map-type.Rmd ## 3.Rmd 31-function.Rmd 32-args.Rmd ## 33-intermediate.Rmd 34-args-default.Rmd 35-args-multi.Rmd ## 36-args-matching.Rmd 4.Rmd 41-map2.Rmd ## 42-mutate-map.Rmd 43-unnest.Rmd ## 2.Rmd 21-intro.Rmd 22-dir.Rmd ## 23-names.Rmd 24-index.Rmd 25-construct.Rmd ## 26-map.Rmd 27-map-manip.Rmd 28-map-type.Rmd ## 3.Rmd 31-function.Rmd 32-args.Rmd ## 33-intermediate.Rmd 34-args-default.Rmd 35-args-multi.Rmd ## 36-args-matching.Rmd 4.Rmd 41-map2.Rmd ## 42-mutate-map.Rmd 43-unnest.Rmd 2.4 Indexing/subsetting Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) Here we look at the indexing of a named vector (works equivalently for a named list). We start with the data frame dict from section ‚ÄúNamed vectors and two-column tibbles‚Äù. Create named vector of the ‚Äì future ‚Äì input files: input_files &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() input_files ## berlin toronto ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; ## tel_aviv zurich ## &quot;data/weather/tel_aviv.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; names(input_files) ## [1] &quot;berlin&quot; &quot;toronto&quot; &quot;tel_aviv&quot; &quot;zurich&quot; There are different ways of accessing individual entries of the named vector: input_files[1] ## berlin ## &quot;data/weather/berlin.xlsx&quot; input_files[[1]] ## [1] &quot;data/weather/berlin.xlsx&quot; input_files[[&quot;berlin&quot;]] ## [1] &quot;data/weather/berlin.xlsx&quot; Choose multiple entries with: input_files[1:2] ## berlin toronto ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/toronto.xlsx&quot; input_files[c(&quot;berlin&quot;, &quot;zurich&quot;)] ## berlin zurich ## &quot;data/weather/berlin.xlsx&quot; &quot;data/weather/zurich.xlsx&quot; Consistent pipe-friendly access of single elements: input_files %&gt;% pluck(1) ## [1] &quot;data/weather/berlin.xlsx&quot; input_files %&gt;% pluck(&quot;berlin&quot;) ## [1] &quot;data/weather/berlin.xlsx&quot; 2.4.1 Exercises Explain the difference between [ and [[ subsetting. Implement a variant of subsetting in ‚Äútibble-land‚Äù with a combination of enframe(), slice() or filter(), and deframe(): input_files %&gt;% enframe() %&gt;% ___(_____) %&gt;% deframe() ## toronto ## &quot;data/weather/toronto.xlsx&quot; 2.5 Construction Click here to show setup code. The c() function constructs vectors. All elements of a vector must have the same type. c(1, 2, 3) ## [1] 1 2 3 c(1:3, 5) ## [1] 1 2 3 5 c(1:3, &quot;5&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;5&quot; Lists are constructed with list(). They are a special type of vector ‚Äì they can contain elements of different type and length. list(1, 2, 3) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 list(1:3, 5) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 5 list(1:3, &quot;5&quot;) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;5&quot; Lists can also contain other lists. list( 1:3, list(4, &quot;5&quot;), list( list(letters[6:8]), 9 ) ) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [[2]][[1]] ## [1] 4 ## ## [[2]][[2]] ## [1] &quot;5&quot; ## ## ## [[3]] ## [[3]][[1]] ## [[3]][[1]][[1]] ## [1] &quot;f&quot; &quot;g&quot; &quot;h&quot; ## ## ## [[3]][[2]] ## [1] 9 Vectors (and also lists) can have names. c(a = 1, b = 2, c = 3) ## a b c ## 1 2 3 list(a = 1:3, b = 5) ## $a ## [1] 1 2 3 ## ## $b ## [1] 5 set_names(1:3, letters[1:3]) ## a b c ## 1 2 3 The new {vctrs} package defines a data type for lists where all elements have the same type: a stricter list, but more powerful than a bare vector. #vctrs::list_of(1, 2, 3) #vctrs::list_of(letters[1:3], &quot;e&quot;) 2.5.1 Exercises Explain the differences between the outputs below. c(a = list(1:3), b = list(4:5)) ## $a ## [1] 1 2 3 ## ## $b ## [1] 4 5 list(a = list(1:3), b = list(4:5)) ## $a ## $a[[1]] ## [1] 1 2 3 ## ## ## $b ## $b[[1]] ## [1] 4 5 2.6 Processing multiple files Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_files &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() Here we look at how to act on each entry of a list or a vector using purrr::map(): We start with the named vector input_files from section ‚ÄúIndexing‚Äù. As just seen, manually choosing just one entry of a vector works like so: readxl::read_excel(here(input_files[[1]])) ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; With map(), you can successively work through the whole vector and each time let the same function deal with the respective entry. The output of map() is a list where each element contains one results. The list is named if the input is named: input_data &lt;- map(input_files, ~ readxl::read_excel(here(.))) Let‚Äôs take a closer look at what we produced: input_data ## $berlin ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## $zurich ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0.267 0.28 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0.198 0.27 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0.137 0.25 ## # ‚Ä¶ with 46 more rows, and 13 more variables: precipType &lt;chr&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt; input_data[[1]] ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; names(input_data) ## [1] &quot;berlin&quot; &quot;toronto&quot; &quot;tel_aviv&quot; &quot;zurich&quot; map() can be included in your pipe in the following way: input_files %&gt;% map(~ readxl::read_excel(here(.))) ## $berlin ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## $zurich ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0.267 0.28 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0.198 0.27 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0.137 0.25 ## # ‚Ä¶ with 46 more rows, and 13 more variables: precipType &lt;chr&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt; 2.6.1 Exercises Read only the data for Toronto and Tel Aviv, using subsetting or filter(). Compare. input_files[_____] %&gt;% map(~ readxl::read_excel(here(.))) input_files %&gt;% ___() %&gt;% filter(name %in% c(_____)) %&gt;% ___() %&gt;% map(~ readxl::read_excel(here(.))) ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; Compute the absolute file name with here() outside of the map() call. input_files %&gt;% enframe() %&gt;% ___(_____) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(.)) ## $berlin ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $toronto ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; ## ## $tel_aviv ## # A tibble: 49 x 17 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Partly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Clear clea‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Clear clea‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 12 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt; ## ## $zurich ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0.267 0.28 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0.198 0.27 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0.137 0.25 ## # ‚Ä¶ with 46 more rows, and 13 more variables: precipType &lt;chr&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt; Can you explain what happens when you call enframe() on the result? Can you explain? input_files %&gt;% map(~ readxl::read_excel(here(.))) %&gt;% enframe() 2.7 Manipulating all datasets Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) How to selectively manipulate specific parts of a list of datasets? We start with the named list of tibbles called input_data from section ‚ÄúProcessing all files‚Äù. Of each tibble we only want the column time and all the columns whose name contains ‚Äúemperature‚Äù. We test with the first entry: input_data[[1]] %&gt;% select(time, contains(&quot;emperature&quot;)) ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 13.4 13.4 ## 2 2019-04-28 16:00:00 13.6 13.6 ## 3 2019-04-28 17:00:00 14.1 14.1 ## # ‚Ä¶ with 46 more rows To apply this on all entries, we use map() again. Note that we need an explicit dot (.) in the select() call here, to indicate the position where each sub-dataset will be plugged in. input_data %&gt;% map(~ select(., time, contains(&quot;emperature&quot;))) ## $berlin ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 13.4 13.4 ## 2 2019-04-28 16:00:00 13.6 13.6 ## 3 2019-04-28 17:00:00 14.1 14.1 ## # ‚Ä¶ with 46 more rows ## ## $toronto ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 7.46 3.96 ## 2 2019-04-28 16:00:00 8.17 5.04 ## 3 2019-04-28 17:00:00 8.82 6.52 ## # ‚Ä¶ with 46 more rows ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # ‚Ä¶ with 46 more rows ## ## $zurich ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 6.96 3.89 ## 2 2019-04-28 16:00:00 7.14 4.33 ## 3 2019-04-28 17:00:00 7.32 5.41 ## # ‚Ä¶ with 46 more rows We can extend this to preserve only the observations with temperature greater or equal than 14¬∞C: input_data %&gt;% map(~ select(., time, contains(&quot;emperature&quot;))) %&gt;% map(~ filter(., temperature &gt;= 14)) ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # ‚Ä¶ with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # ‚Ä¶ with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # ‚Ä¶ with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 Create a custom function for that specific purpose in a call to map(): manipulator &lt;- function(data) { data %&gt;% select(time, contains(&quot;emperature&quot;)) %&gt;% filter(temperature &gt;= 14) } Let‚Äôs look at the object manipulator, that we created: manipulator ## function(data) { ## data %&gt;% ## select(time, contains(&quot;emperature&quot;)) %&gt;% ## filter(temperature &gt;= 14) ## } ## &lt;environment: 0x2477f80&gt; See the ‚ÄúFunction basics‚Äù chapter for a more extensive introduction to functions. Testing the function: manipulator(input_data[[4]]) ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 Now let‚Äôs use map() to let our function act on the entire dataset: manipulated_data &lt;- map(input_data, ~ manipulator(.)) manipulated_data ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # ‚Ä¶ with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # ‚Ä¶ with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # ‚Ä¶ with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 map() allows for the following shortcut notation for functions with one argument only: map(input_data, manipulator) ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 17:00:00 14.1 14.1 ## 2 2019-04-29 12:00:00 15.6 15.6 ## 3 2019-04-29 13:00:00 17.4 17.4 ## # ‚Ä¶ with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # ‚Ä¶ with 3 variables: time &lt;dttm&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 23.9 23.9 ## 2 2019-04-28 16:00:00 23.1 23.1 ## 3 2019-04-28 17:00:00 22.4 22.4 ## # ‚Ä¶ with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30 15:00:00 14.3 14.3 2.7.1 Exercises Use summarize() to compute the mean temperature and humidity for each city during that period. input_data %&gt;% ___(~ ___(., mean(___), mean(___))) ## $berlin ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 12.5 0.634 ## ## $toronto ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 6.39 0.597 ## ## $tel_aviv ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 22.6 0.526 ## ## $zurich ## # A tibble: 1 x 2 ## `mean(temperature)` `mean(humidity)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 7.15 0.776 Create a function to compute the daily mean of these values for each dataset: compute_daily_mean &lt;- ___(data) { data %&gt;% ___(as.Date(time)) %&gt;% ___(_____) %&gt;% ungroup() } input_data %&gt;% ___(___) ## $berlin ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 12.2 0.636 ## 2 2019-04-29 12.7 0.690 ## 3 2019-04-30 12.3 0.551 ## ## $toronto ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 8.96 0.398 ## 2 2019-04-29 5.84 0.554 ## 3 2019-04-30 5.76 0.774 ## ## $tel_aviv ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 21.9 0.542 ## 2 2019-04-29 23.6 0.477 ## 3 2019-04-30 21.7 0.591 ## ## $zurich ## # A tibble: 3 x 3 ## `as.Date(time)` `mean(temperature)` `mean(humidity)` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 5.80 0.778 ## 2 2019-04-29 7.09 0.756 ## 3 2019-04-30 7.98 0.803 Use the dim() function to compute the dimensions of each sub-dataset. Then, use prod() to compute the number of cells. Discuss your observation. input_data %&gt;% _____ input_data %&gt;% _____ %&gt;% _____ ## $berlin ## [1] 49 18 ## ## $toronto ## [1] 49 18 ## ## $tel_aviv ## [1] 49 17 ## ## $zurich ## [1] 49 18 ## $berlin ## [1] 882 ## ## $toronto ## [1] 882 ## ## $tel_aviv ## [1] 833 ## ## $zurich ## [1] 882 Create four plots of humidity vs.¬†pressure, one for each city. Use geom_path(), map temperature to the color aesthetic: create_plot &lt;- function(___) { ___ %&gt;% ggplot(aes(_____)) + geom_path() } ___ %&gt;% ___(___) ## $berlin ## ## $toronto ## ## $tel_aviv ## ## $zurich 2.8 Typed output Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) If we know, what the output of each function call in a map() sequence looks like, we can often call a sub-type of map() to produce a more condensed output. We start with the named list of tibbles called input_data from section ‚ÄúProcessing all files‚Äù. We want to know the number of rows of each tibble in input_data: input_data %&gt;% map(~ nrow(.)) ## $berlin ## [1] 49 ## ## $toronto ## [1] 49 ## ## $tel_aviv ## [1] 49 ## ## $zurich ## [1] 49 Each time an integer is produced. Therefore we can call map_int(), to create a named integer vector: input_data %&gt;% map_int(~ nrow(.)) ## berlin toronto tel_aviv zurich ## 49 49 49 49 If the output is a character variable, use map_chr(): input_data %&gt;% map_chr(~ as.character(nrow(.))) ## berlin toronto tel_aviv zurich ## &quot;49&quot; &quot;49&quot; &quot;49&quot; &quot;49&quot; There are sub-types of the map() function for each atomic type: integer: map_int() numeric (double-precision value): map_dbl() character (strings): map_chr() logical (flags): map_lgl() raw (bytes): map_raw() 2.8.1 Exercises Explain what happens if you try to use map_dbl() with the dim() output: input_data %&gt;% map_dbl(dim) Extract a concise version of the first temperature value for each dataset: input_data %&gt;% map(~ slice(., 1)) %&gt;% ___(~ pull(_____)) ## berlin toronto tel_aviv zurich ## 13.43 7.46 23.90 6.96 Use paste0() to build a textual description for the weather during the observed period in a function. Create a two-column tibble. summarize_weather &lt;- _____ { ___ %&gt;% ___( _____, _____, _____, summary = paste(rle(summary)$values, collapse = &quot;, then &quot;) ) } describe_weather &lt;- function(weather_summary) { weather_summary %&gt;% mutate( text = paste0( &quot;We had temperatures between &quot;, min_temp, &quot; and &quot;, max_temp, &quot; ¬∞C.&quot;, &quot;The average humidity was &quot;, round(mean_humidity * 100), &quot; %. &quot;, &quot;The weather was &quot;, summary, &quot;.&quot; ) ) %&gt;% pull() } input_data %&gt;% ___(___) %&gt;% ___(___) %&gt;% ___() ## # A tibble: 4 x 2 ## name value ## &lt;chr&gt; &lt;chr&gt; ## 1 berlin We had temperatures between 6.14 and 19.98 ¬∞C.The average humid‚Ä¶ ## 2 toronto We had temperatures between 3.03 and 9.99 ¬∞C.The average humidi‚Ä¶ ## 3 tel_aviv We had temperatures between 17.15 and 28.77 ¬∞C.The average humi‚Ä¶ ## 4 zurich We had temperatures between 2.01 and 14.3 ¬∞C.The average humidi‚Ä¶ function here::here() is taking care of making sure we start from the root directory of our current project‚Ü© "],
["function-basics.html", "3 Function basics 3.1 Definition and execution 3.2 Arguments 3.3 Use case: Intermediate variables 3.4 Default values 3.5 Multiple arguments 3.6 Argument matching", " 3 Function basics Structuring the code to avoid too much copy-pasting 3.1 Definition and execution Click here to show setup code. library(tidyverse) library(here) In this chapter the basics of function definitions are covered. 3.1.1 Designing functions Create functions for tasks that need to be executed frequently. read_weather_data &lt;- function() { # Read all files berlin &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;berlin.xlsx&quot;)) toronto &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;toronto.xlsx&quot;)) tel_aviv &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;tel_aviv.xlsx&quot;)) zurich &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;zurich.xlsx&quot;)) # Create ensemble dataset weather_data &lt;- bind_rows( berlin = berlin, toronto = toronto, tel_aviv = tel_aviv, zurich = zurich, .id = &quot;city_code&quot; ) # Return it weather_data } Display the code of any function by writing its name without the subsequent parentheses: read_weather_data ## function() { ## # Read all files ## berlin &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;berlin.xlsx&quot;)) ## toronto &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;toronto.xlsx&quot;)) ## tel_aviv &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;tel_aviv.xlsx&quot;)) ## zurich &lt;- readxl::read_excel(here(&quot;data/weather&quot;, &quot;zurich.xlsx&quot;)) ## ## # Create ensemble dataset ## weather_data &lt;- bind_rows( ## berlin = berlin, ## toronto = toronto, ## tel_aviv = tel_aviv, ## zurich = zurich, ## .id = &quot;city_code&quot; ## ) ## ## # Return it ## weather_data ## } ## &lt;environment: 0x2477f80&gt; Execute the function by adding the parentheses: read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; List R-objects in an environment: ls() ## [1] &quot;read_weather_data&quot; Assign function values to a variable: weather_data &lt;- read_weather_data() 3.2 Arguments Click here to show setup code. library(tidyverse) library(here) By adding arguments to your functions, you can turn them into tools for a wide range of applications. But it is advisable to be conservative here: try to minimise the number of arguments to the necessary ones, so the user has a clear and intuitive interface to deal with. Functions with arguments: weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } Call functions from within functions: read_weather_data &lt;- function() { # Read all files berlin &lt;- readxl::read_excel(weather_path(&quot;berlin.xlsx&quot;)) toronto &lt;- readxl::read_excel(weather_path(&quot;toronto.xlsx&quot;)) tel_aviv &lt;- readxl::read_excel(weather_path(&quot;tel_aviv.xlsx&quot;)) zurich &lt;- readxl::read_excel(weather_path(&quot;zurich.xlsx&quot;)) # Create ensemble dataset weather_data &lt;- bind_rows( berlin = berlin, toronto = toronto, tel_aviv = tel_aviv, zurich = zurich, .id = &quot;city_code&quot; ) # Return it weather_data } Always immediately test the newly created function by running it (best with varying parameters): read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 3.3 Use case: Intermediate variables Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } We start with the function weather_path() from section ‚ÄúArguments‚Äù. Functions can help to avoid having to use intermediate variables: read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } read_weather_data &lt;- function() { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Return it weather_data } read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; Here we create a function weather_path_for() that wraps a character variable in a path with the correct file ending. This function is in turn called by read_ecxel() in our function get_weather_for2(). As a result, get_weather_for2() works the same way as get_weather_for() (below), but it is easier to read and looks slightly more elegant: get_weather_for &lt;- function(city) { filename &lt;- paste0(city, &quot;.xlsx&quot;) readxl::read_excel( paste0( weather_path(filename) ) ) } weather_path_for &lt;- function(city) { here(&quot;data/weather&quot;, paste0(city, &quot;.xlsx&quot;)) } get_weather_for2 &lt;- function(city) { readxl::read_excel(weather_path_for(city)) } read_weather_data &lt;- function() { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = get_weather_for2(&quot;berlin&quot;), toronto = get_weather_for2(&quot;toronto&quot;), tel_aviv = get_weather_for2(&quot;tel_aviv&quot;), zurich = get_weather_for2(&quot;zurich&quot;), .id = &quot;city_code&quot; ) # Return it weather_data } read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 3.4 Default values Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } For user-friendliness it is often good practice to provide default values for parameters We start with the functions weather_path() from section ‚ÄúArguments‚Äù and read_weather_file() from section ‚ÄúIntermediate variables‚Äù. Here an example of a boolean argument which when TRUE leads to dropping the data about Zurich. read_weather_data &lt;- function(omit_zurich = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Return it (filtered) weather_data %&gt;% filter( !(city_code == &quot;zurich&quot; &amp; omit_zurich) ) } Set arguments with default values explicitly with or without using the name or leave them out to use the default value: read_weather_data(TRUE) ## # A tibble: 147 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 144 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; read_weather_data(omit_zurich = TRUE) ## # A tibble: 147 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 144 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 3.5 Multiple arguments Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } We start once more with the functions weather_path() from section ‚ÄúArguments‚Äù and read_weather_file() from section ‚ÄúIntermediate variables‚Äù. What are the considerations when using multiple function arguments? You can add new parameters in a very straightforward manner like this: read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Return it (filtered) weather_data %&gt;% filter( !(city_code == &quot;zurich&quot; &amp; omit_zurich) ) %&gt;% filter( !(city_code == &quot;toronto&quot; &amp; omit_toronto) ) } Use the so called ellipsis (...) when you want to provide the possibility for the user to call your function with a list of arguments of unspecified length. This can be e.g.¬†useful for passing arguments downstream: weather_path &lt;- function(...) { # All arguments are passed on here(&quot;data/weather&quot;, ...) } weather_path(&quot;berlin.xlsx&quot;) ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/berlin.xlsx&quot; weather_path(&quot;some&quot;, &quot;subdir&quot;, &quot;with&quot;, &quot;a&quot;, &quot;file.csv&quot;) ## [1] &quot;/home/travis/build/krlmlr/tidyprog/data/weather/some/subdir/with/a/file.csv&quot; Mind, that despite altering the original function and adding new features to it, the original call still works as before: read_weather_data() ## # A tibble: 196 x 19 ## city_code time summary icon precipIntensity ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 berlin 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 2 berlin 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## 3 berlin 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 ## # ‚Ä¶ with 193 more rows, and 14 more variables: precipProbability &lt;dbl&gt;, ## # temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, ## # windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # ozone &lt;dbl&gt;, precipType &lt;chr&gt; 3.5.1 Exercise read_weather_data(TRUE, omit_z = FALSE) %&gt;% count(city_code) ## # A tibble: 3 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 zurich 49 See the next section for ideas on avoiding this behavior. 3.6 Argument matching Click here to show setup code. How does R handle function calls with arguments? Named arguments are assigned first, after that remaining slots are filled from left to right. use_names &lt;- function(a = 1, b = 2) { list(a = a, b = b) } use_names(3, 4) ## $a ## [1] 3 ## ## $b ## [1] 4 use_names(a = 3, 4) ## $a ## [1] 3 ## ## $b ## [1] 4 use_names(3, a = 4) ## $a ## [1] 4 ## ## $b ## [1] 3 use_names(a = 3, b = 4) ## $a ## [1] 3 ## ## $b ## [1] 4 The ellipsis can be used to enforce the user to name the function parameters when setting them: enforce_names &lt;- function(..., a = 1, b = 2) { list(a = a, b = b) } enforce_names(3, 4) ## $a ## [1] 1 ## ## $b ## [1] 2 enforce_names(a = 3, 4) ## $a ## [1] 3 ## ## $b ## [1] 2 enforce_names(a = 3, b = 4) ## $a ## [1] 3 ## ## $b ## [1] 4 Inside a function with an ellipsis as a parameter, you can capture the ellipsis with list(): ellipsis_test &lt;- function(...) { args &lt;- list(...) names(args) } ellipsis_test(a = 1, 2, c = 3:5) ## [1] &quot;a&quot; &quot;&quot; &quot;c&quot; 3.6.1 Exercise Naming, not naming or partly naming parameters in functions calls? What does the following return and why? use_some_names &lt;- function(a = 1, ..., b = 2) { list(a = a, b = b) } use_some_names(3, 4) ## $a ## [1] 3 ## ## $b ## [1] 2 use_some_names(a = 3, 4) ## $a ## [1] 3 ## ## $b ## [1] 2 use_some_names(3, a = 4) ## $a ## [1] 4 ## ## $b ## [1] 2 use_some_names(a = 3, b = 4) ## $a ## [1] 3 ## ## $b ## [1] 4 use_some_names(b = 4, 3) ## $a ## [1] 3 ## ## $b ## [1] 4 use_always_names &lt;- function(..., a = 1, b = 2) { extra_args &lt;- list(...) stopifnot(length(extra_args) == 0) list(a = a, b = b) } try(use_always_names(3, 4)) ## Error in use_always_names(3, 4) : length(extra_args) == 0 is not TRUE try(use_always_names(a = 3, 4)) ## Error in use_always_names(a = 3, 4) : length(extra_args) == 0 is not TRUE try(use_always_names(3, a = 4)) ## Error in use_always_names(3, a = 4) : length(extra_args) == 0 is not TRUE try(use_always_names(b = 4, 3)) ## Error in use_always_names(b = 4, 3) : length(extra_args) == 0 is not TRUE use_always_names(a = 3, b = 4) ## $a ## [1] 3 ## ## $b ## [1] 4 "],
["pairwise-iteration-and-nesting.html", "4 Pairwise iteration and nesting 4.1 Manipulating pairwise 4.2 Moving to tibble-land 4.3 Nesting and unnesting", " 4 Pairwise iteration and nesting 4.1 Manipulating pairwise Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) manipulator &lt;- function(data) { data %&gt;% select(time, contains(&quot;emperature&quot;)) %&gt;% filter(temperature &gt;= 14) } manipulated_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) %&gt;% map(manipulator) Here we take cases into consideration, when you want to iterate through two lists (of the same length) in parallel and use each value pair as two of the input parameters of a function. We start with the reduced list of tibbles manipulated_data from ‚ÄúManipulating all datasets‚Äù. We first prepare a list of future output filenames: output_filenames &lt;- tempfile(names(manipulated_data), fileext = &quot;.csv&quot;) output_filenames ## [1] &quot;/tmp/Rtmp7RV01w/berlin2c351bf51547.csv&quot; ## [2] &quot;/tmp/Rtmp7RV01w/toronto2c35fd1ae28.csv&quot; ## [3] &quot;/tmp/Rtmp7RV01w/tel_aviv2c357f35cefb.csv&quot; ## [4] &quot;/tmp/Rtmp7RV01w/zurich2c3529969375.csv&quot; We want to use readr::write_csv() to write each tibble into the respective file. write_csv() needs at least 2 arguments: the tibble itself and the path to the filename. We use map2() to handle this: map2(manipulated_data, output_filenames, ~ readr::write_csv(..1, ..2)) ## $berlin ## # A tibble: 16 x 3 ## time temperature apparentTemperature ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28T17:00:00Z 14.1 14.1 ## 2 2019-04-29T12:00:00Z 15.6 15.6 ## 3 2019-04-29T13:00:00Z 17.4 17.4 ## # ‚Ä¶ with 13 more rows ## ## $toronto ## # A tibble: 0 x 3 ## # ‚Ä¶ with 3 variables: time &lt;chr&gt;, temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt; ## ## $tel_aviv ## # A tibble: 49 x 3 ## time temperature apparentTemperature ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28T15:00:00Z 23.9 23.9 ## 2 2019-04-28T16:00:00Z 23.1 23.1 ## 3 2019-04-28T17:00:00Z 22.4 22.4 ## # ‚Ä¶ with 46 more rows ## ## $zurich ## # A tibble: 1 x 3 ## time temperature apparentTemperature ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-30T15:00:00Z 14.3 14.3 Since we are just interested in the side-effects of write_csv() and not in the displayed output, we rather use the related function walk2(), which does not return output. walk2(manipulated_data, output_filenames, ~ readr::write_csv(..1, ..2)) 4.2 Moving to tibble-land Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) input_data &lt;- dict %&gt;% select(city_code, weather_filename) %&gt;% deframe() %&gt;% map(~ readxl::read_excel(here(.))) How to combine the abilities of map() &amp; co., which work on vectors and lists, with our commonly used data structure, the tibble? We start with the named list of tibbles called input_data from section ‚ÄúProcessing all files‚Äù and with dict from section ‚ÄúNamed vectors and two-column tibbles‚Äù. Produce a data frame from input_data with enframe() leads to a maybe at first surprising, but oftentimes useful result: input_data %&gt;% enframe() ## # A tibble: 4 x 2 ## name value ## &lt;chr&gt; &lt;list&gt; ## 1 berlin &lt;tibble [49 √ó 18]&gt; ## 2 toronto &lt;tibble [49 √ó 18]&gt; ## 3 tel_aviv &lt;tibble [49 √ó 17]&gt; ## 4 zurich &lt;tibble [49 √ó 18]&gt; This is because lists are also vectors. In our case each list entry contains a tibble, which can be ‚Äúnested‚Äù into each entry of column value. Starting with the tibble dict we can see how dpylr::mutate() and map() can nicely work together to produce a somewhat similar result: dict %&gt;% select(city_code, weather_filename) %&gt;% mutate( data = map(weather_filename, ~ readxl::read_excel(here(.))) ) ## # A tibble: 4 x 3 ## city_code weather_filename data ## &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 berlin data/weather/berlin.xlsx &lt;tibble [49 √ó 18]&gt; ## 2 toronto data/weather/toronto.xlsx &lt;tibble [49 √ó 18]&gt; ## 3 tel_aviv data/weather/tel_aviv.xlsx &lt;tibble [49 √ó 17]&gt; ## 4 zurich data/weather/zurich.xlsx &lt;tibble [49 √ó 18]&gt; This works because R interprets columns of tibbles as vectors, which can be fed to map(). Deselect i.e.¬†drop columns using select() with -: dict_data &lt;- dict %&gt;% mutate( data = map(weather_filename, ~ readxl::read_excel(here(.))) ) %&gt;% select(-weather_filename) dict_data ## # A tibble: 4 x 5 ## city_code name lng lat data ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 berlin Berlin 13.4 52.5 &lt;tibble [49 √ó 18]&gt; ## 2 toronto Toronto -79.4 43.7 &lt;tibble [49 √ó 18]&gt; ## 3 tel_aviv Tel Aviv 34.8 32.1 &lt;tibble [49 √ó 17]&gt; ## 4 zurich Z√ºrich 8.54 47.4 &lt;tibble [49 √ó 18]&gt; 4.3 Nesting and unnesting Click here to show setup code. library(tidyverse) library(here) dict &lt;- readxl::read_excel(here(&quot;data/cities.xlsx&quot;)) dict_data &lt;- dict %&gt;% mutate(data = map(weather_filename, ~ readxl::read_excel(here(.)))) %&gt;% select(-weather_filename) How to work with nested data? We start with the tibble dict_data from section ‚ÄúMoving to tibble-land‚Äù, which includes the nested tibbles in its column data. If we want to actually look at the data we can directly use tidyr::unnest() on the whole tibble, which by default acts on all list-columns. This blows up our tibble by repeating the formerly unnested column entries as many times, as each nested tibble has rows: dict_data %&gt;% unnest() ## # A tibble: 196 x 22 ## city_code name lng lat time summary icon ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 berlin Berl‚Ä¶ 13.4 52.5 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ ## 2 berlin Berl‚Ä¶ 13.4 52.5 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ ## 3 berlin Berl‚Ä¶ 13.4 52.5 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ ## # ‚Ä¶ with 193 more rows, and 15 more variables: precipIntensity &lt;dbl&gt;, ## # precipProbability &lt;dbl&gt;, temperature &lt;dbl&gt;, apparentTemperature &lt;dbl&gt;, ## # dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, ## # windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, ## # visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, precipType &lt;chr&gt; dict_data %&gt;% unnest() %&gt;% count(name) ## # A tibble: 4 x 2 ## name n ## &lt;chr&gt; &lt;int&gt; ## 1 Berlin 49 ## 2 Tel Aviv 49 ## 3 Toronto 49 ## 4 Z√ºrich 49 Inversely, if you want to have a more condensed view of your data, you can nest again. By default, the function tidyr::nest() will nest all data. Therefore it is often useful to tell it, which columns to ignore: dict_data %&gt;% unnest() %&gt;% nest(-city_code, -name, -lng, -lat) ## # A tibble: 4 x 5 ## city_code name lng lat data ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 berlin Berlin 13.4 52.5 &lt;tibble [49 √ó 18]&gt; ## 2 toronto Toronto -79.4 43.7 &lt;tibble [49 √ó 18]&gt; ## 3 tel_aviv Tel Aviv 34.8 32.1 &lt;tibble [49 √ó 18]&gt; ## 4 zurich Z√ºrich 8.54 47.4 &lt;tibble [49 √ó 18]&gt; Using this, we structure our data in new, customized ways. Here, we create a new column date, by dropping the detailed information of the time of the day, and create a nested tibble for each day: dict_data %&gt;% unnest() %&gt;% mutate(date = as.Date(time)) %&gt;% nest(-date) ## # A tibble: 3 x 2 ## date data ## &lt;date&gt; &lt;list&gt; ## 1 2019-04-28 &lt;tibble [36 √ó 22]&gt; ## 2 2019-04-29 &lt;tibble [96 √ó 22]&gt; ## 3 2019-04-30 &lt;tibble [64 √ó 22]&gt; "],
["scoping-and-flow-control.html", "5 Scoping and flow control 5.1 Scope 5.2 Pure functions and side effects 5.3 Control flow 5.4 Closures", " 5 Scoping and flow control 5.1 Scope Click here to show setup code. a &lt;- 5 In the setup code we assigned a &lt;- 5. a is now an object of the global environment. A function can access global variables: f &lt;- function() { a } f() ## [1] 5 On the other hand, a variable which is defined inside a function, will not be known outside of that function. Respectively, it won‚Äôt overwrite the value of global variables. f &lt;- function() { a &lt;- 2 a } f() ## [1] 2 a ## [1] 5 Global variables are a (hidden) part of a function‚Äôs interface. Best practice: functions should be self-contained, independent of global variables. invisible() 5.2 Pure functions and side effects Click here to show setup code. library(tidyverse) Functions should do one thing, and do it well.3 Pure function: A function that is called for its return value and which has no side effects: pure_function &lt;- function(x) { x + 1 } pure_function(1) ## [1] 2 Function with side effect: called for its side effect, returns input (here invisibly; assigning is possible): side_effect_function &lt;- function(x) { file &lt;- tempfile() writeLines(format(x), tempfile()) print(x) message(x, &quot; written to &quot;, file) invisible(x) } side_effect_function(2) ## [1] 2 ## 2 written to /tmp/Rtmp7RV01w/file2c355d76aecb Separation helps isolate the side effects. If side effect functions return the input, they remain composable with pure functions: 5 %&gt;% pure_function() %&gt;% side_effect_function() %&gt;% pure_function() ## [1] 6 ## 6 written to /tmp/Rtmp7RV01w/file2c353c8d4b71 ## [1] 7 5.3 Control flow Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } We start once more with the functions weather_path() from section ‚ÄúArguments‚Äù and read_weather_file() from section ‚ÄúIntermediate variables‚Äù. A way to regulate the control flow is by using if (): read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Filter, conditionally if (omit_zurich) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;zurich&quot;) } if (omit_toronto) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;toronto&quot;) } # Return result weather_data } read_weather_data(omit_toronto = TRUE, omit_zurich = TRUE) %&gt;% count(city_code) ## # A tibble: 2 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 read_weather_data(omit_toronto = TRUE, omit_zurich = FALSE) %&gt;% count(city_code) ## # A tibble: 3 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 zurich 49 This can be useful if aiming at a possible early return: read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Can keep original data? if (!omit_zurich &amp;&amp; !omit_toronto) { return(weather_data) } # Filter, conditionally if (omit_zurich) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;zurich&quot;) } if (omit_toronto) { weather_data &lt;- weather_data %&gt;% filter(city_code != &quot;toronto&quot;) } # Return result weather_data } Conditional branching with if-else-logic. (This is just for illustration, you should not implement code like this!) read_weather_data &lt;- function(omit_zurich = FALSE, omit_toronto = FALSE) { # Create ensemble dataset from files on disk weather_data &lt;- bind_rows( berlin = read_weather_file(&quot;berlin.xlsx&quot;), toronto = read_weather_file(&quot;toronto.xlsx&quot;), tel_aviv = read_weather_file(&quot;tel_aviv.xlsx&quot;), zurich = read_weather_file(&quot;zurich.xlsx&quot;), .id = &quot;city_code&quot; ) # Filter, conditionally, and return if (!omit_zurich &amp;&amp; !omit_toronto) { weather_data } else if (omit_zurich &amp;&amp; !omit_toronto) { weather_data %&gt;% filter(city_code != &quot;zurich&quot;) } else if (!omit_zurich &amp;&amp; omit_toronto) { weather_data %&gt;% filter(city_code != &quot;toronto&quot;) } else { # Filter both weather_data %&gt;% filter(city_code != &quot;zurich&quot;) %&gt;% filter(city_code != &quot;toronto&quot;) } } read_weather_data(omit_toronto = TRUE) %&gt;% count(city_code) ## # A tibble: 3 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 zurich 49 read_weather_data(omit_zurich = TRUE) %&gt;% count(city_code) ## # A tibble: 3 x 2 ## city_code n ## &lt;chr&gt; &lt;int&gt; ## 1 berlin 49 ## 2 tel_aviv 49 ## 3 toronto 49 5.4 Closures Click here to show setup code. library(tidyverse) library(here) weather_path &lt;- function(filename) { # Returned value here(&quot;data/weather&quot;, filename) } read_weather_file &lt;- function(filename) { readxl::read_excel(weather_path(filename)) } Closures can e.g.¬†be used during function definition. We start once more with the functions weather_path() from section ‚ÄúArguments‚Äù and read_weather_file() from section ‚ÄúIntermediate variables‚Äù. Here we create a function that loads a particular dataset: make_read_weather_file &lt;- function(filename) { # Avoid odd effects due to lazy evaluation force(filename) # This function (closure) accesses the filename from the # outer function f &lt;- function() { read_weather_file(filename) } f } read_berlin &lt;- make_read_weather_file(&quot;berlin.xlsx&quot;) read_toronto &lt;- make_read_weather_file(&quot;toronto.xlsx&quot;) read_tel_aviv &lt;- make_read_weather_file(&quot;tel_aviv.xlsx&quot;) read_zurich &lt;- make_read_weather_file(&quot;zurich.xlsx&quot;) read_berlin ## function() { ## read_weather_file(filename) ## } ## &lt;environment: 0xacf0130&gt; read_berlin() ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; Use closures as wrappers for other verbs/functions (such functions are also called ‚Äúadverbs‚Äù): loudly &lt;- function(f) { force(f) function(...) { args &lt;- list(...) msg &lt;- paste0(length(args), &quot; argument(s)&quot;) message(msg) f(...) } } read_loudly &lt;- loudly(read_weather_file) read_loudly ## function(...) { ## args &lt;- list(...) ## msg &lt;- paste0(length(args), &quot; argument(s)&quot;) ## message(msg) ## ## f(...) ## } ## &lt;environment: 0x54991e8&gt; read_loudly(&quot;berlin.xlsx&quot;) ## 1 argument(s) ## # A tibble: 49 x 18 ## time summary icon precipIntensity precipProbabili‚Ä¶ ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-04-28 15:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 2 2019-04-28 16:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## 3 2019-04-28 17:00:00 Mostly‚Ä¶ part‚Ä¶ 0 0 ## # ‚Ä¶ with 46 more rows, and 13 more variables: temperature &lt;dbl&gt;, ## # apparentTemperature &lt;dbl&gt;, dewPoint &lt;dbl&gt;, humidity &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windGust &lt;dbl&gt;, windBearing &lt;dbl&gt;, ## # cloudCover &lt;dbl&gt;, uvIndex &lt;dbl&gt;, visibility &lt;dbl&gt;, ozone &lt;dbl&gt;, ## # precipType &lt;chr&gt; Unix philosophy, originated by Ken Thompson‚Ü© "],
["non-rectangular-data.html", "6 Non-rectangular data 6.1 Traversing 6.2 Iterating and traversing 6.3 Plucking multiple locations 6.4 Flattening 6.5 Transposing 6.6 Rectangling 6.7 Accessing APIs", " 6 Non-rectangular data working with raw data from online services (JSON) 6.1 Traversing Click here to show setup code. library(tidyverse) library(here) We are now working with the results from downloading geolocation data from photon.komoot.de. This is stored in the file here(&quot;data/komoot-berlin.rds&quot;) and we can read it with readRDS(): berlin &lt;- readRDS(here(&quot;data/komoot-berlin.rds&quot;)) berlin ## $features ## $features[[1]] ## $features[[1]]$geometry ## $features[[1]]$geometry$coordinates ## $features[[1]]$geometry$coordinates[[1]] ## [1] 13.38886 ## ## $features[[1]]$geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## $features[[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[1]]$type ## [1] &quot;Feature&quot; ## ## $features[[1]]$properties ## $features[[1]]$properties$osm_id ## [1] 240109189 ## ## $features[[1]]$properties$osm_type ## [1] &quot;N&quot; ## ## $features[[1]]$properties$country ## [1] &quot;Germany&quot; ## ## $features[[1]]$properties$osm_key ## [1] &quot;place&quot; ## ## $features[[1]]$properties$city ## [1] &quot;Berlin&quot; ## ## $features[[1]]$properties$osm_value ## [1] &quot;city&quot; ## ## $features[[1]]$properties$postcode ## [1] &quot;10117&quot; ## ## $features[[1]]$properties$name ## [1] &quot;Berlin&quot; ## ## ## ## ## $type ## [1] &quot;FeatureCollection&quot; str(berlin) ## List of 2 ## $ features:List of 1 ## ..$ :List of 3 ## .. ..$ geometry :List of 2 ## .. .. ..$ coordinates:List of 2 ## .. .. .. ..$ : num 13.4 ## .. .. .. ..$ : num 52.5 ## .. .. ..$ type : chr &quot;Point&quot; ## .. ..$ type : chr &quot;Feature&quot; ## .. ..$ properties:List of 8 ## .. .. ..$ osm_id : int 240109189 ## .. .. ..$ osm_type : chr &quot;N&quot; ## .. .. ..$ country : chr &quot;Germany&quot; ## .. .. ..$ osm_key : chr &quot;place&quot; ## .. .. ..$ city : chr &quot;Berlin&quot; ## .. .. ..$ osm_value: chr &quot;city&quot; ## .. .. ..$ postcode : chr &quot;10117&quot; ## .. .. ..$ name : chr &quot;Berlin&quot; ## $ type : chr &quot;FeatureCollection&quot; As you can see it is a somewhat complex list structure. We know from ‚ÄúIndexing‚Äù that we can access it‚Äôs components in the following way: berlin$type ## [1] &quot;FeatureCollection&quot; berlin$features ## [[1]] ## [[1]]$geometry ## [[1]]$geometry$coordinates ## [[1]]$geometry$coordinates[[1]] ## [1] 13.38886 ## ## [[1]]$geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## [[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## [[1]]$type ## [1] &quot;Feature&quot; ## ## [[1]]$properties ## [[1]]$properties$osm_id ## [1] 240109189 ## ## [[1]]$properties$osm_type ## [1] &quot;N&quot; ## ## [[1]]$properties$country ## [1] &quot;Germany&quot; ## ## [[1]]$properties$osm_key ## [1] &quot;place&quot; ## ## [[1]]$properties$city ## [1] &quot;Berlin&quot; ## ## [[1]]$properties$osm_value ## [1] &quot;city&quot; ## ## [[1]]$properties$postcode ## [1] &quot;10117&quot; ## ## [[1]]$properties$name ## [1] &quot;Berlin&quot; berlin$features[[1]] ## $geometry ## $geometry$coordinates ## $geometry$coordinates[[1]] ## [1] 13.38886 ## ## $geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## $geometry$type ## [1] &quot;Point&quot; ## ## ## $type ## [1] &quot;Feature&quot; ## ## $properties ## $properties$osm_id ## [1] 240109189 ## ## $properties$osm_type ## [1] &quot;N&quot; ## ## $properties$country ## [1] &quot;Germany&quot; ## ## $properties$osm_key ## [1] &quot;place&quot; ## ## $properties$city ## [1] &quot;Berlin&quot; ## ## $properties$osm_value ## [1] &quot;city&quot; ## ## $properties$postcode ## [1] &quot;10117&quot; ## ## $properties$name ## [1] &quot;Berlin&quot; With the function purrr::pluck(), there is however a more universal tool available for accessing elements of more complex lists: berlin %&gt;% pluck(&quot;type&quot;) ## [1] &quot;FeatureCollection&quot; berlin %&gt;% pluck(&quot;features&quot;) ## [[1]] ## [[1]]$geometry ## [[1]]$geometry$coordinates ## [[1]]$geometry$coordinates[[1]] ## [1] 13.38886 ## ## [[1]]$geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## [[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## [[1]]$type ## [1] &quot;Feature&quot; ## ## [[1]]$properties ## [[1]]$properties$osm_id ## [1] 240109189 ## ## [[1]]$properties$osm_type ## [1] &quot;N&quot; ## ## [[1]]$properties$country ## [1] &quot;Germany&quot; ## ## [[1]]$properties$osm_key ## [1] &quot;place&quot; ## ## [[1]]$properties$city ## [1] &quot;Berlin&quot; ## ## [[1]]$properties$osm_value ## [1] &quot;city&quot; ## ## [[1]]$properties$postcode ## [1] &quot;10117&quot; ## ## [[1]]$properties$name ## [1] &quot;Berlin&quot; berlin %&gt;% pluck(&quot;features&quot;, 1) ## $geometry ## $geometry$coordinates ## $geometry$coordinates[[1]] ## [1] 13.38886 ## ## $geometry$coordinates[[2]] ## [1] 52.51704 ## ## ## $geometry$type ## [1] &quot;Point&quot; ## ## ## $type ## [1] &quot;Feature&quot; ## ## $properties ## $properties$osm_id ## [1] 240109189 ## ## $properties$osm_type ## [1] &quot;N&quot; ## ## $properties$country ## [1] &quot;Germany&quot; ## ## $properties$osm_key ## [1] &quot;place&quot; ## ## $properties$city ## [1] &quot;Berlin&quot; ## ## $properties$osm_value ## [1] &quot;city&quot; ## ## $properties$postcode ## [1] &quot;10117&quot; ## ## $properties$name ## [1] &quot;Berlin&quot; berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;) ## $coordinates ## $coordinates[[1]] ## [1] 13.38886 ## ## $coordinates[[2]] ## [1] 52.51704 ## ## ## $type ## [1] &quot;Point&quot; berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) ## [[1]] ## [1] 13.38886 ## ## [[2]] ## [1] 52.51704 Similarly: berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;properties&quot;, &quot;country&quot;) ## [1] &quot;Germany&quot; And as one more important characteristic of a tidyverse-function, pluck() is pipe-able: berlin %&gt;% pluck(&quot;features&quot;, 1) %&gt;% pluck(&quot;properties&quot;, &quot;country&quot;) ## [1] &quot;Germany&quot; 6.2 Iterating and traversing Click here to show setup code. library(tidyverse) library(here) Now we are not only working with the geolocation data for Berlin, but we are adding data for our usual suspects: komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot ## # A tibble: 4 x 6 ## name url_name url res status content ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 Berlin Berlin https://photon.komoot.de/ap‚Ä¶ &lt;S3: res‚Ä¶ &lt;NULL&gt; &lt;list [‚Ä¶ ## 2 Toronto Toronto https://photon.komoot.de/ap‚Ä¶ &lt;S3: res‚Ä¶ &lt;NULL&gt; &lt;list [‚Ä¶ ## 3 Tel Av‚Ä¶ Tel%20Aviv https://photon.komoot.de/ap‚Ä¶ &lt;S3: res‚Ä¶ &lt;NULL&gt; &lt;list [‚Ä¶ ## 4 Z√ºrich Z%C3%BCri‚Ä¶ https://photon.komoot.de/ap‚Ä¶ &lt;S3: res‚Ä¶ &lt;NULL&gt; &lt;list [‚Ä¶ It looks slightly different from the list berlin from section ‚ÄúTraversing‚Äù. That is because we have the list-of-2 stored for each city in the column content. By using pull() on content, we can produce a list containing the information for all cities: komoot_content &lt;- komoot %&gt;% pull(content) berlin &lt;- komoot_content %&gt;% pluck(1) berlin %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) ## [[1]] ## [1] 13.38886 ## ## [[2]] ## [1] 52.51704 toronto &lt;- komoot_content %&gt;% pluck(2) toronto %&gt;% pluck(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) ## [[1]] ## [1] -79.38721 ## ## [[2]] ## [1] 43.65396 With map() we can access the same element of the respective list for each city: komoot_content %&gt;% map(~ pluck(., &quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 With map() we can also use a shorthand notation for this, without the need to use pluck(). We can just give it a list of the arguments which we would normally use as arguments for pluck(): komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 The acces path can also be stored in a variable: accessor &lt;- list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) coordinates &lt;- komoot_content %&gt;% map(accessor) coordinates ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 6.3 Plucking multiple locations Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) What if we want to access two different pieces of information of each main list point at once? We are again starting in the setup with the list komoot_content from ‚ÄúIterating and traversing‚Äù. Let‚Äôs define the two locations of the city-lists we would like to access: accessor_coords &lt;- list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;) komoot_content %&gt;% map(accessor_coords) ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] 52.51704 ## ## ## [[2]] ## [[2]][[1]] ## [1] -79.38721 ## ## [[2]][[2]] ## [1] 43.65396 ## ## ## [[3]] ## [[3]][[1]] ## [1] 34.78053 ## ## [[3]][[2]] ## [1] 32.08048 ## ## ## [[4]] ## [[4]][[1]] ## [1] 8.542322 ## ## [[4]][[2]] ## [1] 47.3724 accessor_country &lt;- list(&quot;features&quot;, 1, &quot;properties&quot;, &quot;country&quot;) komoot_content %&gt;% map(accessor_country) ## [[1]] ## [1] &quot;Germany&quot; ## ## [[2]] ## [1] &quot;Canada&quot; ## ## [[3]] ## [1] &quot;Israel&quot; ## ## [[4]] ## [1] &quot;Switzerland&quot; Combine them as a list of lists and hand it over to a map() inside a map(): accessors &lt;- list(coords = accessor_coords, country = accessor_country) accessors %&gt;% map(~ map(komoot_content, .)) ## $coords ## $coords[[1]] ## $coords[[1]][[1]] ## [1] 13.38886 ## ## $coords[[1]][[2]] ## [1] 52.51704 ## ## ## $coords[[2]] ## $coords[[2]][[1]] ## [1] -79.38721 ## ## $coords[[2]][[2]] ## [1] 43.65396 ## ## ## $coords[[3]] ## $coords[[3]][[1]] ## [1] 34.78053 ## ## $coords[[3]][[2]] ## [1] 32.08048 ## ## ## $coords[[4]] ## $coords[[4]][[1]] ## [1] 8.542322 ## ## $coords[[4]][[2]] ## [1] 47.3724 ## ## ## ## $country ## $country[[1]] ## [1] &quot;Germany&quot; ## ## $country[[2]] ## [1] &quot;Canada&quot; ## ## $country[[3]] ## [1] &quot;Israel&quot; ## ## $country[[4]] ## [1] &quot;Switzerland&quot; 6.4 Flattening Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) coordinates &lt;- komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) It can occur that we end up with lists which are unnecessarily deep and we would like to make them flatter to make it easier to handle them. We are starting in our setup with komoot_content and coordinates from section ‚ÄúIterating and traversing‚Äù. An example for an list that seems a bit too deep is given here: coordinates %&gt;% pluck(1) ## [[1]] ## [1] 13.38886 ## ## [[2]] ## [1] 52.51704 We can chop off a layer of a list and end up with a vector with one of the functions purrr::flatten_*(). In the * we need to specify what class the output will be: coordinates %&gt;% pluck(1) %&gt;% flatten_dbl() ## [1] 13.38886 52.51704 Let‚Äôs use map() to apply this to the entire list of our cities‚Äô coordinates: coordinates %&gt;% map(~ flatten_dbl(.)) ## [[1]] ## [1] 13.38886 52.51704 ## ## [[2]] ## [1] -79.38721 43.65396 ## ## [[3]] ## [1] 34.78053 32.08048 ## ## [[4]] ## [1] 8.542322 47.372396 6.5 Transposing Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) coordinates &lt;- komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) You might know the mathematical concept of transposition from your linear algebra courses. A similar concept is available in R when we are dealing with lists. We are starting in our setup with komoot_content and coordinates from section ‚ÄúIterating and traversing‚Äù. Let‚Äôs apply purrr::transpose() to our list coordinates: coordinates %&gt;% transpose() ## [[1]] ## [[1]][[1]] ## [1] 13.38886 ## ## [[1]][[2]] ## [1] -79.38721 ## ## [[1]][[3]] ## [1] 34.78053 ## ## [[1]][[4]] ## [1] 8.542322 ## ## ## [[2]] ## [[2]][[1]] ## [1] 52.51704 ## ## [[2]][[2]] ## [1] 43.65396 ## ## [[2]][[3]] ## [1] 32.08048 ## ## [[2]][[4]] ## [1] 47.3724 What was originally a list with 4 elements of which each one was a list of 2 elements has become a list of 2 elements of which each one is a list of 4 elements. With flatten_dbl() we can simplify the structure, so that we end up with a list of 2, where each element consists of a vector of 4. The first vector contains the longitude and the second the latitude of our cities: coordinates_transposed &lt;- coordinates %&gt;% transpose() %&gt;% map(~ flatten_dbl(.)) 6.6 Rectangling Click here to show setup code. library(tidyverse) library(here) komoot &lt;- readRDS(here(&quot;data/komoot.rds&quot;)) komoot_content &lt;- komoot %&gt;% pull(content) coordinates_transposed &lt;- komoot_content %&gt;% map(list(&quot;features&quot;, 1, &quot;geometry&quot;, &quot;coordinates&quot;)) %&gt;% transpose() %&gt;% map(~ flatten_dbl(.)) Most of us R-users feel most at ease when dealing in R with data frames on which we can use a plethora of well-known (by us) functions with non-startling behaviour. What if we don‚Äôt get our data in such a form? We are starting in our setup with the list coordinates_transposed from section ‚ÄúTransposing‚Äù. A tibble is internally a list of named vectors of equal length. In two easy steps we can therefore make a tibble out of the unnamed list coordinates_transposed: coordinates_transposed %&gt;% set_names(c(&quot;lon&quot;, &quot;lat&quot;)) ## $lon ## [1] 13.388860 -79.387207 34.780527 8.542322 ## ## $lat ## [1] 52.51704 43.65396 32.08048 47.37240 coordinates_transposed %&gt;% set_names(c(&quot;lon&quot;, &quot;lat&quot;)) %&gt;% as_tibble() ## # A tibble: 4 x 2 ## lon lat ## &lt;dbl&gt; &lt;dbl&gt; ## 1 13.4 52.5 ## 2 -79.4 43.7 ## 3 34.8 32.1 ## 4 8.54 47.4 If you want to keep the names open for now, but still get a tibble, you can set as_tibble()‚Äôs argument .name_repair = &quot;universal&quot;: coordinates_transposed %&gt;% as_tibble(.name_repair = &quot;universal&quot;) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## # A tibble: 4 x 2 ## ...1 ...2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 13.4 52.5 ## 2 -79.4 43.7 ## 3 34.8 32.1 ## 4 8.54 47.4 coordinates_transposed %&gt;% as_tibble(.name_repair = &quot;universal&quot;) %&gt;% rename(lon = ...1, lat = ...2) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## # A tibble: 4 x 2 ## lon lat ## &lt;dbl&gt; &lt;dbl&gt; ## 1 13.4 52.5 ## 2 -79.4 43.7 ## 3 34.8 32.1 ## 4 8.54 47.4 6.7 Accessing APIs Click here to show setup code. library(tidyverse) library(here) req &lt;- httr::GET(&quot;https://photon.komoot.de/api/?q=Paradeplatz&amp;limit=3&quot;) httr::stop_for_status(req) content &lt;- httr::content(req) content ## $features ## $features[[1]] ## $features[[1]]$geometry ## $features[[1]]$geometry$coordinates ## $features[[1]]$geometry$coordinates[[1]] ## [1] 8.538948 ## ## $features[[1]]$geometry$coordinates[[2]] ## [1] 47.36981 ## ## ## $features[[1]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[1]]$type ## [1] &quot;Feature&quot; ## ## $features[[1]]$properties ## $features[[1]]$properties$osm_id ## [1] 905841 ## ## $features[[1]]$properties$osm_type ## [1] &quot;R&quot; ## ## $features[[1]]$properties$extent ## $features[[1]]$properties$extent[[1]] ## [1] 8.538163 ## ## $features[[1]]$properties$extent[[2]] ## [1] 47.37027 ## ## $features[[1]]$properties$extent[[3]] ## [1] 8.539516 ## ## $features[[1]]$properties$extent[[4]] ## [1] 47.36935 ## ## ## $features[[1]]$properties$country ## [1] &quot;Switzerland&quot; ## ## $features[[1]]$properties$osm_key ## [1] &quot;highway&quot; ## ## $features[[1]]$properties$city ## [1] &quot;Zurich&quot; ## ## $features[[1]]$properties$osm_value ## [1] &quot;pedestrian&quot; ## ## $features[[1]]$properties$postcode ## [1] &quot;8001&quot; ## ## $features[[1]]$properties$name ## [1] &quot;Paradeplatz&quot; ## ## $features[[1]]$properties$state ## [1] &quot;Zurich&quot; ## ## ## ## $features[[2]] ## $features[[2]]$geometry ## $features[[2]]$geometry$coordinates ## $features[[2]]$geometry$coordinates[[1]] ## [1] 7.108249 ## ## $features[[2]]$geometry$coordinates[[2]] ## [1] 50.88602 ## ## ## $features[[2]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[2]]$type ## [1] &quot;Feature&quot; ## ## $features[[2]]$properties ## $features[[2]]$properties$osm_id ## [1] 389550464 ## ## $features[[2]]$properties$osm_type ## [1] &quot;N&quot; ## ## $features[[2]]$properties$country ## [1] &quot;Germany&quot; ## ## $features[[2]]$properties$osm_key ## [1] &quot;place&quot; ## ## $features[[2]]$properties$city ## [1] &quot;Cologne&quot; ## ## $features[[2]]$properties$osm_value ## [1] &quot;locality&quot; ## ## $features[[2]]$properties$postcode ## [1] &quot;51147&quot; ## ## $features[[2]]$properties$name ## [1] &quot;Paradeplatz&quot; ## ## $features[[2]]$properties$state ## [1] &quot;North Rhine-Westphalia&quot; ## ## ## ## $features[[3]] ## $features[[3]]$geometry ## $features[[3]]$geometry$coordinates ## $features[[3]]$geometry$coordinates[[1]] ## [1] 8.684258 ## ## $features[[3]]$geometry$coordinates[[2]] ## [1] 49.38674 ## ## ## $features[[3]]$geometry$type ## [1] &quot;Point&quot; ## ## ## $features[[3]]$type ## [1] &quot;Feature&quot; ## ## $features[[3]]$properties ## $features[[3]]$properties$osm_id ## [1] 391678888 ## ## $features[[3]]$properties$osm_type ## [1] &quot;W&quot; ## ## $features[[3]]$properties$extent ## $features[[3]]$properties$extent[[1]] ## [1] 8.683635 ## ## $features[[3]]$properties$extent[[2]] ## [1] 49.38719 ## ## $features[[3]]$properties$extent[[3]] ## [1] 8.68488 ## ## $features[[3]]$properties$extent[[4]] ## [1] 49.3863 ## ## ## $features[[3]]$properties$country ## [1] &quot;Germany&quot; ## ## $features[[3]]$properties$osm_key ## [1] &quot;place&quot; ## ## $features[[3]]$properties$city ## [1] &quot;Heidelberg&quot; ## ## $features[[3]]$properties$osm_value ## [1] &quot;locality&quot; ## ## $features[[3]]$properties$postcode ## [1] &quot;69120&quot; ## ## $features[[3]]$properties$name ## [1] &quot;Paradeplatz&quot; ## ## $features[[3]]$properties$state ## [1] &quot;Baden-W√ºrttemberg&quot; ## ## ## ## ## $type ## [1] &quot;FeatureCollection&quot; text_content &lt;- httr::content(req, as = &quot;text&quot;) cat(text_content) ## {&quot;features&quot;:[{&quot;geometry&quot;:{&quot;coordinates&quot;:[8.538948327037028,47.369806999999994],&quot;type&quot;:&quot;Point&quot;},&quot;type&quot;:&quot;Feature&quot;,&quot;properties&quot;:{&quot;osm_id&quot;:905841,&quot;osm_type&quot;:&quot;R&quot;,&quot;extent&quot;:[8.5381631,47.3702704,8.5395156,47.3693475],&quot;country&quot;:&quot;Switzerland&quot;,&quot;osm_key&quot;:&quot;highway&quot;,&quot;city&quot;:&quot;Zurich&quot;,&quot;osm_value&quot;:&quot;pedestrian&quot;,&quot;postcode&quot;:&quot;8001&quot;,&quot;name&quot;:&quot;Paradeplatz&quot;,&quot;state&quot;:&quot;Zurich&quot;}},{&quot;geometry&quot;:{&quot;coordinates&quot;:[7.1082488,50.8860177],&quot;type&quot;:&quot;Point&quot;},&quot;type&quot;:&quot;Feature&quot;,&quot;properties&quot;:{&quot;osm_id&quot;:389550464,&quot;osm_type&quot;:&quot;N&quot;,&quot;country&quot;:&quot;Germany&quot;,&quot;osm_key&quot;:&quot;place&quot;,&quot;city&quot;:&quot;Cologne&quot;,&quot;osm_value&quot;:&quot;locality&quot;,&quot;postcode&quot;:&quot;51147&quot;,&quot;name&quot;:&quot;Paradeplatz&quot;,&quot;state&quot;:&quot;North Rhine-Westphalia&quot;}},{&quot;geometry&quot;:{&quot;coordinates&quot;:[8.684257597277371,49.3867415],&quot;type&quot;:&quot;Point&quot;},&quot;type&quot;:&quot;Feature&quot;,&quot;properties&quot;:{&quot;osm_id&quot;:391678888,&quot;osm_type&quot;:&quot;W&quot;,&quot;extent&quot;:[8.6836355,49.3871856,8.6848797,49.3862973],&quot;country&quot;:&quot;Germany&quot;,&quot;osm_key&quot;:&quot;place&quot;,&quot;city&quot;:&quot;Heidelberg&quot;,&quot;osm_value&quot;:&quot;locality&quot;,&quot;postcode&quot;:&quot;69120&quot;,&quot;name&quot;:&quot;Paradeplatz&quot;,&quot;state&quot;:&quot;Baden-W√ºrttemberg&quot;}}],&quot;type&quot;:&quot;FeatureCollection&quot;} cat(jsonlite::prettify(text_content)) ## { ## &quot;features&quot;: [ ## { ## &quot;geometry&quot;: { ## &quot;coordinates&quot;: [ ## 8.538948327037028, ## 47.369806999999994 ## ], ## &quot;type&quot;: &quot;Point&quot; ## }, ## &quot;type&quot;: &quot;Feature&quot;, ## &quot;properties&quot;: { ## &quot;osm_id&quot;: 905841, ## &quot;osm_type&quot;: &quot;R&quot;, ## &quot;extent&quot;: [ ## 8.5381631, ## 47.3702704, ## 8.5395156, ## 47.3693475 ## ], ## &quot;country&quot;: &quot;Switzerland&quot;, ## &quot;osm_key&quot;: &quot;highway&quot;, ## &quot;city&quot;: &quot;Zurich&quot;, ## &quot;osm_value&quot;: &quot;pedestrian&quot;, ## &quot;postcode&quot;: &quot;8001&quot;, ## &quot;name&quot;: &quot;Paradeplatz&quot;, ## &quot;state&quot;: &quot;Zurich&quot; ## } ## }, ## { ## &quot;geometry&quot;: { ## &quot;coordinates&quot;: [ ## 7.1082488, ## 50.8860177 ## ], ## &quot;type&quot;: &quot;Point&quot; ## }, ## &quot;type&quot;: &quot;Feature&quot;, ## &quot;properties&quot;: { ## &quot;osm_id&quot;: 389550464, ## &quot;osm_type&quot;: &quot;N&quot;, ## &quot;country&quot;: &quot;Germany&quot;, ## &quot;osm_key&quot;: &quot;place&quot;, ## &quot;city&quot;: &quot;Cologne&quot;, ## &quot;osm_value&quot;: &quot;locality&quot;, ## &quot;postcode&quot;: &quot;51147&quot;, ## &quot;name&quot;: &quot;Paradeplatz&quot;, ## &quot;state&quot;: &quot;North Rhine-Westphalia&quot; ## } ## }, ## { ## &quot;geometry&quot;: { ## &quot;coordinates&quot;: [ ## 8.684257597277371, ## 49.3867415 ## ], ## &quot;type&quot;: &quot;Point&quot; ## }, ## &quot;type&quot;: &quot;Feature&quot;, ## &quot;properties&quot;: { ## &quot;osm_id&quot;: 391678888, ## &quot;osm_type&quot;: &quot;W&quot;, ## &quot;extent&quot;: [ ## 8.6836355, ## 49.3871856, ## 8.6848797, ## 49.3862973 ## ], ## &quot;country&quot;: &quot;Germany&quot;, ## &quot;osm_key&quot;: &quot;place&quot;, ## &quot;city&quot;: &quot;Heidelberg&quot;, ## &quot;osm_value&quot;: &quot;locality&quot;, ## &quot;postcode&quot;: &quot;69120&quot;, ## &quot;name&quot;: &quot;Paradeplatz&quot;, ## &quot;state&quot;: &quot;Baden-W√ºrttemberg&quot; ## } ## } ## ], ## &quot;type&quot;: &quot;FeatureCollection&quot; ## } "],
["tidy-evaluation.html", "7 Tidy evaluation", " 7 Tidy evaluation writing functions that work with datasets of different shape "],
["references.html", "# References", " # References R for data science: https://r4ds.had.co.nz/ Row oriented workflows: https://github.com/jennybc/row-oriented-workflows#readme Advanced R: http://adv-r.had.co.nz/ Tidy evaluation: https://tidyeval.tidyverse.org/ R packages: http://r-pkgs.had.co.nz/ How R searches and finds stuff: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/ What they forgot to teach you: https://whattheyforgot.org/ Parallel processing with a purrr-like interface: https://davisvaughan.github.io/furrr/ "]
]
