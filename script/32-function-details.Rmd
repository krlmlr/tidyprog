```{r 32-remove-all, include = FALSE}
rm(list = ls())
```


## Arguments

```{r include = FALSE}
# Setup 32-function-details.R
```
```{r 32-setup-32-function-details-r}
library(tidyverse)
library(here)
library(conflicted)

conflict_prefer("filter", "dplyr")


weather_path <- function(filename) {
  # Returned value
  here("data/weather", filename)
}
read_weather_file <- function(filename) {
  readxl::read_excel(weather_path(filename))
}
```


### Further options when creating functions

Provide default values for parameters:

```{r include = FALSE}
# Function arguments can have default values
```
```{r 32-function-arguments-can-have-default-values}
read_weather_data <- function(omit_zurich = FALSE) {
  # Create ensemble dataset from files on disk
  weather_data <- bind_rows(
    berlin = read_weather_file("berlin.xlsx"),
    toronto = read_weather_file("toronto.xlsx"),
    tel_aviv = read_weather_file("tel_aviv.xlsx"),
    zurich = read_weather_file("zurich.xlsx"),
    .id = "city_code"
  )

  # Return it (filtered)
  weather_data %>%
    filter( !(city_code == "zurich" & omit_zurich) )
}
```


Set arguments with default values explicitly with or without using the name or leave them out to use the default value:

```{r include = FALSE}
# Function arguments can be called by name or by position,
# optional arguments are omitted
```
```{r 32-function-arguments-can-be-called-by-name-or-by-position}
read_weather_data(TRUE)
read_weather_data(omit_zurich = TRUE)
read_weather_data()
```

Multiple function arguments:

```{r include = FALSE}
# Multiple function arguments are separated by comma:
```
```{r 32-multiple-function-arguments-are-separated-by-comma}
read_weather_data <- function(omit_zurich = FALSE, omit_toronto = FALSE) {
  # Create ensemble dataset from files on disk
  weather_data <- bind_rows(
    berlin = read_weather_file("berlin.xlsx"),
    toronto = read_weather_file("toronto.xlsx"),
    tel_aviv = read_weather_file("tel_aviv.xlsx"),
    zurich = read_weather_file("zurich.xlsx"),
    .id = "city_code"
  )

  # Return it (filtered)
  weather_data %>%
    filter( !(city_code == "zurich" & omit_zurich) ) %>%
    filter( !(city_code == "toronto" & omit_toronto) )
}
```

Ellipsis (`...`) for list of arguments of unspecified length. Useful for passing arguments downstream:

```{r include = FALSE}
# Ellipsis: variable argument list, useful for passing arguments downstream
```
```{r 32-ellipsis-variable-argument-list-useful-for-passing-arguments-downstream}
weather_path <- function(...) {
  # All arguments are passed on
  here("data/weather", ...)
}

weather_path("berlin.xlsx")

weather_path("some", "subdir", "with", "a", "file.csv")
```


Mind, that despite altering the original function and adding new features to it, the original call still works as before:

```{r include = FALSE}
# Note: despite many changes and new features,
# the original call still works!
# (This can be tested automatically!)
```
```{r 32-note-despite-many-changes-and-new-features}
read_weather_data()
```

Argument matching: named arguments are assigned first, after that remaining slots are filled from left to right.

```{r include = FALSE}
# Call matching
```
```{r 32-call-matching}
use_names <- function(a = 1, b = 2) {
  list(a = a, b = b)
}

use_names(3, 4)
use_names(a = 3, 4)
use_names(3, a = 4)
use_names(a = 3, b = 4)
```

The ellipsis can be used to enfore the user to name the function parameters when setting them:

```{r include = FALSE}
# The ellipsis is useful to enforce naming of arguments
```
```{r 32-the-ellipsis-is-useful-to-enforce-naming-of-arguments}
enforce_names <- function(..., a = 1, b = 2) {
  list(a = a, b = b)
}

enforce_names(3, 4)
enforce_names(a = 3, 4)
enforce_names(a = 3, b = 4)
```

Inside a function with an ellipsis as a parameter, you can capture the ellipsis with `list()`:

```{r include = FALSE}
# Arguments in ellipsis can be captured via list()
```
```{r 32-arguments-in-ellipsis-can-be-captured-via-list}
ellipsis_test <- function(...) {
  args <- list(...)
  names(args)
}

ellipsis_test(a = 1, 2, c = 3:5)
```


### Exercise

Naming, not naming or partly naming parameters in functions calls? What does the following return and why?

```{r include = FALSE}
## Exercise: call matching
```
```{r 32-exercise-call-matching}

```


```{r include = FALSE}
## What does the following return? Why?
```
```{r 32-what-does-the-following-return-why}
read_weather_data(TRUE, omit_z = FALSE) %>%
  count(city_code)
```


```{r include = FALSE}
## How do you avoid this behavior?
```
```{r 32-how-do-you-avoid-this-behavior}

```


```{r include = FALSE}
## Ellipsis inbetween
```
```{r 32-ellipsis-inbetween}


use_some_names <- function(a = 1, ..., b = 2) {
  list(a = a, b = b)
}

use_some_names(3, 4)
use_some_names(a = 3, 4)
use_some_names(3, a = 4)
use_some_names(a = 3, b = 4)
use_some_names(b = 4, 3)
```


```{r include = FALSE}
## Program defensively!
```
```{r 32-program-defensively}

use_always_names <- function(a = 1, ..., b = 2) {
  extra_args <- list(...)
  stopifnot(length(extra_args) == 0)

  list(a = a, b = b)
}

use_always_names(3, 4)
use_always_names(a = 3, 4)
use_always_names(3, a = 4)
use_always_names(a = 3, b = 4)
use_always_names(b = 4, 3)

use_always_names <- function(a = 1, ..., b = 2) {
  extra_args <- list(...)
  stopifnot(length(extra_args) == 0)

  list(a = a, b = b)
}
```
