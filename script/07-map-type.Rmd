```{r 07-remove-all, include = FALSE}
rm(list = ls())
```

## Typed output



<details><summary>Click here to make setup code visible</summary>
```{r include = FALSE}
### Typed output

```
```{r 07-setup-07-map-type-r}
library(tidyverse)
library(here)

dict <- readxl::read_excel(here("data/cities.xlsx"))

input_data <-
  dict %>%
  select(city_code, weather_filename) %>%
  deframe() %>%
  map(~ readxl::read_excel(here(.)))
```
</details>

If we know, what the output of each function call in a `map()` sequence looks like, we can often call a sub-type of `map()` to produce a more condensed output.

We start with the named list of tibbles called `input_data` from section ["Processing all files"](#map).

We want to know the number of rows of each tibble in `input_data`:

```{r include = FALSE}
# map() returns a list
```
```{r 07-map-returns-a-list}
input_data %>%
  map(~ nrow(.))
```

Each time an integer is produced.
Therefore we can call `map_int()`, to create a named integer vector:

```{r include = FALSE}
# Return an integer vector with map_int()
```
```{r 07-return-an-integer-vector-with-map-int}
input_data %>%
  map_int(~ nrow(.))
```

If the output is a character variable, use `map_chr()`:

```{r include = FALSE}
# ... or a character vector?
```
```{r 07-or-a-character-vector}
input_data %>%
  map_chr(~ as.character(nrow(.)))
```

There are many sub-types of the `map()` function also for other classes of output values available.
